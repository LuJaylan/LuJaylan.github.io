<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="卤蛋的博客">
<meta property="og:url" content="https://lujaylan.github.io/page/2/index.html">
<meta property="og:site_name" content="卤蛋的博客">
<meta property="article:author" content="Jaylan lu">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lujaylan.github.io/page/2/"/>





  <title>卤蛋的博客</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">卤蛋的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">勤学如春起之苗，不见其增，日有所长；辍学如磨刀之石，不见其损，日有所亏</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2019/04/10/iOS-%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/10/iOS-%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/" itemprop="url">iOS 总结（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-10T20:54:00+08:00">
                2019-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###堆栈的区别（宿（速）管分碎地）</p>
<h4 id="地址："><a href="#地址：" class="headerlink" title="地址："></a>地址：</h4><p>栈连续，地址是从高地址往低地址扩展，且最大容量由系统预先规定好，超过剩余空间会overflow；</p>
<p>堆不连续，操作系统有记录空闲内存地址的链表，遍历方向是由低向高地址</p>
<p>####分配：<br>堆都为动态分配，栈有动态和静态分配，静态如局部变量，动态为alloc分配，栈大小固定，但堆大小可由程序员控制</p>
<p>####碎片<br>栈不会有碎片，堆会有碎片，因为堆大小不确定，系统由链表来管理堆，分配时遍历链表，大于所需要的才会分配</p>
<p>####速度<br>栈申请速度快，堆速度慢，栈是由系统寄存器存储进行入栈出栈，堆会按照一定的算法寻找空间</p>
<p>####管理<br>栈由系统管理，堆需要程序员手动管理</p>
<p>###除了网络和服务器问题还有什么情况会导致socket断开<br>服务器的并发连接数超过了其承载量，服务器会将其中一些连接down掉<br>客户关掉了浏览器，而服务器还在给客户端发送数据<br>浏览器按了stop</p>
<p>socket tcp连接失败或者UDP无响应，原因可以从以下三个环节中查找</p>
<p>1 本机防火墙是否屏蔽掉了你使用的端口</p>
<p>2 公司外网路由或网关是否开放了你所指定的协议以及端口</p>
<p>3 外网网站是否允许你所指定的协议以及端口</p>
<p>###链表和数组的区别和使用场景<br>####逻辑结构<br>数组需要实现固定长度，不能动态的增加大小，元素可能超出原先定义的个数，元素少时可能浪费，可用下标操纵</p>
<p>链表为动态分配，可动态增减，可以方便的删除、插入，链表必须根据next找到下一个元素</p>
<p>####内存存储<br>数组从栈中分配，自由度小</p>
<p>链表从堆中分配，自由度大，但申请麻烦</p>
<p>####如要快速访问，很少插入删除就用数组，如经常插入删除就用链表</p>
<p><strong>数组使用场景</strong></p>
<p>1 注重存储密度；</p>
<p>2 经常做的运算时按序号访问数据元素；</p>
<p>3 数组更容易实现，任何高级语言都支持</p>
<p>4 构建的线性表较稳定</p>
<p><strong>链表的使用场景</strong></p>
<p>1 对线性表的长度或规模难以估计；<br>2 频繁做插入删除操作<br>3 构建动态性比较强的线性表</p>
<p>###对象什么时候销毁<br>对象是引用计数为0时被release的，autorelease实际上只是把release的调用延迟了，对于每一个autorelease</p>
<p>###https加密原理<br>其实HTTPS从最终的数据解析的角度，与HTTP没有任何区别，HTTPS就是将HTTP数据协议包放到SSL/TLS层加密后，在TCP/IP层组成IP数据报去传输，以此来保证数据传输的安全；而对于接收端，在SSL/TLS将接收的数据解密之后，将数据传给HTTP协议层，就是普通的HTTP数据了。<br>流程：<br>1，客户端通过发送client hello开始SSL通信。报文中包含客户端支持的SSL的定制版本、加密组件列表（加密算法，密钥长度等）。<br>2，服务器可以进行SSL通信时，会以server hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件是从客户端的加密组件中筛选出来的。<br>3，之后服务器发送certificate报文。报文中包含公开密钥证书；<br>4，最后服务器发送server hello down报文通知客户端，最初阶段的SSL握手协商部分结束。<br>5，SSL第一次握手结束后，客户端以client key exchange报文作为回应。报文中包含通信加密中使用的一种被称为Pre-master secret的随机加密串。改报文已经使用步骤3中的公开密钥进行加密。<br>6，接着客户端继续发送change cipher spec报文；<br>7，服务器同样发送finished报文；<br>10，服务器和客户端的finish博文交换完毕后，SSL连接就算建立完成。当然，通信会收到SSL的保护。从此处开始进行应用层协议的通信，即发送HTTP请求；<br>11，应用层协议通信，即发送HTTP响应；<br>12，最后由客户端断开连接。断开连接时，发送close_notify报文。这步之后再发送TCP FIN报文来关闭与TCP的通信。</p>
<p>或者<br>SSL协议最开始的握手协议是这样的：<br>1，客户端的浏览器向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需的各种信息。<br>2，服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还向客户端传送自己的证书。<br>3，客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA是否可靠，发行证书的公钥能否正确解开服务器证书的”发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配，检查证书是否在证书撤销列表（CRL）中。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四部。<br>4，用户端随机产生一个用于后面通讯的堆成秘钥，然后用服务器的公钥（服务器的公钥从步骤2中的服务器的证书中获取的）对其加密，然后将加密后的预主秘钥（pre master secret）传给服务器。<br>5，如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户资金的证书以及加密过的预主秘钥一起传给服务器。<br>6，如果服务器要求客户的身份认证，服务器必须检验客户证书的签名随机数的合法性，检测方法和3中类似，如果验证通过，服务器用自己的私钥解开加密的预主秘钥，然后执行一系列步骤来产生主秘钥（master secret）。客户也使用相同方法，从预主秘钥得到主秘钥。<br>7，握手的主要流程结束。至此服务器与客户端已共享了主密钥。双方使用主密钥可以产生用于通信的密码参数，包括通信对称密钥，mac密钥等。</p>
<p>延伸问题：HTTP是验证CA证书如何认证？<br>1，验证证书是否存在有效期<br>2，验证证书是否被吊销了，有CRL和OCSP，证书被吊销后会记录在CRL中，CRL有两个缺点（1，有可能很大，下载很慢；2滞后性，智能等到发布最新CRL才能知道）</p>
<p>OCSP为在线证书状态检查协议，应用按标准发送一个请求，对某张证书进行查询，之后服务器返回证书状态<br>3，验证证书是否为上级CA签发的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2019/03/25/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%94%81/" itemprop="url">iOS开发中的锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T16:19:07+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2019/03/24/Runloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/Runloop/" itemprop="url">Runloop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T10:03:52+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>说句惭愧的话，关于runloop的文章看了很多遍，一直没弄透，从开始的晦涩难懂、味如嚼蜡到懵懵懂懂，但现在的熟练如心。但是为了更深入地理解和梳理知识，还是写下这篇博客。runloop在官网是有比较详细的介绍的，第一手资料在<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">这里</a></p>
<p>runloop是和线程相关的基础设置的一部分，它是一个事件处理的循环，你可以使用它来调度工作和接受传入的工作。runloop的目的是为了让你的线程在有工作做的时候忙碌，没有工作做的时候休眠。<br>runloop不是完全自动管理的。你必须设计你的线程代码在合适的时间启动线程响应传入的事件。Cocoa和Core Foundation都提供了runloop对象帮助你配置和管理线程 的runloop。你的应用不用明显地创建这些对象；每一个线程（包括主线程），都有一个与之相关联的runloop对象。但是，只有辅助线程才需要明显地运行它们的线程，作为应用启动的一部分，APP frameworks 都自动地设置和运行主线程的runloop。（也就是说，在程序的启动过程中，主线程的runloop就被应用的框架自动设置和运行起来了）。<br>关于runloop的资料可以戳<a href="https://developer.apple.com/documentation/foundation/nsrunloop" target="_blank" rel="noopener">NSRunLoop Class Reference</a> 和 <a href="https://developer.apple.com/documentation/corefoundation/cfrunloop" target="_blank" rel="noopener">CFRunLoop Reference</a>.</p>
<p>###runloop详解<br>runloop 是一个循环，你的线程进入并用它调用时间处理器响应传入的事件。你的代码提供了用于实现运行循环的实际循环部分的控制语句（也就是说你的代码提供了驱动运行循环的while或for循环）。在循环中，runloop对象调用事件处理代码来接收事件并调用已安装的处理程序。<br>一个runloop接收到了来自两个不同类型的sources的事件。输入sources传递异步事件，通常是来自另一个线程或另一个应用程序的消息。Timer sources传递同步时间，发生在预定的时间或重复的间隔。这两种类型的source都使用特定于应用程序的处理程序例程在事件到达时处理事件。<br>以上都是翻译，说真的，有点拗口。</p>
<p>runloop说白了就是一个对象（万物皆对象），这个对象在循环中用来处理程序运行过程中出现的各种事件，从而保证程序的持续运行，而且在没有事件处理的时候，会进入休眠模式，从而节省CPU资源，提高程序性能。</p>
<p>带着问题研究可以加深理解，也更有目的性。先看看下面几个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">基于NSTimer的轮播器什么情况下会被页面滚动暂停，怎样可以不被暂停，为什么？</span><br><span class="line">延迟执行performSelector相关方法是怎样执行的？在子线程中也是一样的吗？</span><br><span class="line">事件响应和收拾识别底层处理是一致的吗，为什么？</span><br><span class="line">界面刷新时，是在什么时候会真正执行刷新，为什么会刷新不及时？</span><br><span class="line">项目成效运行中，总是伴随着多次自动释放池的创建和销毁，这些是在什么时候发生的呢？</span><br><span class="line">当我们在子线程上需要执行代理方法或者回调时，怎么确保当前线程没被销毁？</span><br></pre></td></tr></table></figure>
<p>有的问题可能遇到过，解决过，但问道为什么时，可能就歇菜了。所以为了知其所以然，我们还是得深入。</p>
<p>###runloop基本作用<br>####保持程序持续运行<br>这点上面提到过，程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的runloop，runloop保证主线程不会被销毁，也就保证了程序的持续运行。</p>
<p>####处理APP中的各种事件<br>比如：触摸事件，定时器事件，selector事件<br>####节省CPU资源，提高程序性能<br>这个上面也有提及，当没有什么操作时，runloop就会告诉CPU，现在没事做，我要去休息了，这是CPU就会将其资源释放出去做其他事情，当有事情做的时候，runloop就会立马做事情。<br><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/runloop%EF%BC%88%E4%B8%80%EF%BC%89.png" alt="Aaron Swartz"></p>
<p>上图是runloop概念上的结构和多种sources的图。input sources传递异步事件给相对应的事件处理器并且调用<code>runUntilDate:</code>方法去退出runloop。timer sources传递事件给常规的事件处理器但是不会导致runloop退出。<br>除了处理input source外，runloop还生成关于runloop行为的通知，注册的runloop观察者可以接收这些通知，并使用它们在线程上执行额外的处理。你可以使用Core Foundation在线程上安装运行循环观察者。</p>
<p>我们知道程序的入口都是main函数，我们把Objective-C的main方法改一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;开始&quot;);</span><br><span class="line">        int result &#x3D; UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">        NSLog(@&quot;结束&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现只打印的”开始”没打印”结束”，说明在UIApplicationMain函数中，开启了一个和主线程相关的runloop，导致UIApplicationMain不会返回，一直在运行中，也就保证了程序的持续运行。  </p>
<p>###runloop models  </p>
<ol>
<li>Default: defaultMode 用于大多数操作，大多数情况下，使用该模式启动运行循环并配置输入源。NSDefaultRunLoopMode(Cocoa), kCFRunLoopDefaultMode(Core Foundation)   </li>
<li>Connection：Cocoa将此模式与NSConnection对象结合起来使用来监听响应，一般不需要我们使用   NSConnectionReplyMode（Cocoa）</li>
<li>Modal：使用此模式来标识用于模态面板的事件    NSModalPanelRunLoopMode(Cocoa)  </li>
<li>Event tracking： 界面跟踪mode，确保界面交互时不受其他Mode影响 NSEventTrackingRunLoopMode(Cocoa)  </li>
<li>Common modes：可配置的常用模式。将输入源与此模式关联也将与其组中的所有模式关联。Cocoa里面，默认情况下包含default、modal、event tracking。 Core Foundation最初只包含default。可以使用CFRunLoopAddCommonMode函数添加自定义模式    </li>
</ol>
<p>###线程和RunLoop  </p>
<blockquote>
<p>1.线程和RunLoop之间是一一对应的，其关系是保存在一个全局的Dictionary中的。<br>2.线程刚创建时并没有runloop，如果你不主动获取，它一直都不会有。<br>3.runloop在第一次被获取时创建，在线程结束时被销毁<br>4.除了主线程，只能在线程内部获取其runLoop  </p>
</blockquote>
<p>###autoreleasepool<br>autoreleasepool创建是在runloop事件开始前，释放是在runloop事件结束之前<br>autoreleasepool是由若干个autoreleasepoolpage以双向链表的形式组合而成的栈结构<br>当对象调用autorelease方法时，会将对象加入autoreleasepoolpage的栈中<br>pop时是传入边界对象，然后对page中的对象发送release消息<br>如果hotpage不存在，就新建一个，调用add方法将对象添加到autoreleasepoolpage的栈中<br>如果有hotpage并且当前page已满 调用autoreleasefullpage，初始化一个新的页 调用add方法<br>若有hotpage并且不满 直接调用add方法<br>autoreleasefullpage方法是从传入的page开始遍历双向链表找未满的autoreleasepoolpage 找到未满的page（如果没有就新建）将这个page标识为hotpage 往hotpage中添加对象</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2019/03/24/%E5%BC%80%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/%E5%BC%80%E7%AF%87/" itemprop="url">开篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T09:56:20+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>早就想写博客了，不过一直没有付诸行动，原因只有一个——懒。其实在这个过程中自己也写了一些笔记，这两者差别还是蛮大的：笔记是零散的，主要是记录一些零碎的知识点或者是一些问题的解决方法，这些东西其实网上都是可查的用处不大，反正我的笔记除了翻译其他的基本不会再看；博客不同，写博客其实不是装逼的，也不是写给别人看的，个人认为写博客是整合自己所学的知识点融会贯通、查漏补缺，从而加深理解，完成自己的知识体系。</p>
<p>本文博客的搭建是结合<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>和<a href="https://github.com/" target="_blank" rel="noopener">github</a>的，但是不建议直接看hexo官网，因为太长而且看了也不见得就能搭建搭建起来，有兴趣的朋友们可以参考<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">知乎</a>。<br>在此我就补充三点：<br>一、为了方便，安装node.js建议从<a href="https://nodejs.org/en/" target="_blank" rel="noopener">官网</a>下载。<br>二、可以只需要Blog就好(不需要blog文件夹)、否则容易被那篇文章弄晕了。<br>三、主题菜单配置  Basics: /basics || train （其中Basics是原始的，/basics是source下面的路径，train是<a href="https://fontawesome.com/" target="_blank" rel="noopener">这个网页</a>的图片，但是不是所有的都能显示出来），如果想要翻译，就在对应的语言文件(主题里面language文件夹下的zh-Hans.yml)里面的menu下加上对应的翻译字段（about: 关于）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2019/03/24/%E7%BD%91%E7%BB%9C%E6%9D%82%E8%B0%88%E4%B8%80%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/%E7%BD%91%E7%BB%9C%E6%9D%82%E8%B0%88%E4%B8%80%E4%BA%8C/" itemprop="url">网络杂谈一二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T09:52:51+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在浏览器中输入<a href="http://www.baidu.com，按了回车之后会发生什么？">www.baidu.com，按了回车之后会发生什么？</a><br>1 浏览器会向DNS服务器请求对应的IP地址<br>2 服务器返回IP地址<br>3 浏览器打开tcp，向web服务器发送http请求<br>4 如果出现重定向，服务器会响应重定向，让浏览器在此发起请求<br>5 服务器返回HTTP请求<br>6 浏览器接受页面的源码<br>6 浏览器渲染html<br>7 浏览器拿到内嵌的url<br>8 浏览器发起异步请求<br>9 浏览器关闭tcp连接</p>
<p>get&amp;Post<br>在浏览器中，get返回没响应，post会在此发起请求<br>get的参数是在url中，post是在请求体中<br>get参数只能ASCII编码，post可以任意编码<br>get参数有长度限制，post没有<br>get的url地址可以bookmark ，而post 不行<br>get会被浏览器主动cache，而post不会，除非手动设置<br>get的参数会被完整保留在浏览历史记录中，而post中的参数不会被保留<br>get请求只能进行url编码，而post支持多种编码方式<br>get没有post安全，因为参数直接暴露在url上<br>get参数通过url传递，post放在requestbody中</p>
<p>get产生一个tcp 数据包，post产生两个tcp数据包</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2019/02/18/%E3%80%8A%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/%E3%80%8A%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84%E3%80%8B%E7%AC%94%E8%AE%B0/" itemprop="url">《网络是怎样连接的》笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T16:20:52+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/Internet(%E4%B8%80).png" alt="Aaron Swartz"></p>
<p>包（Packet）:包相当于信件或者包裹，而交换机和路由器相当于邮局或快递公司的分拣处理处，数字信息相当于信的内容，将数字信息分割成一个一个的小块，然后装入一些被称为“包（Packet）的容器中运送”。包的头部存有目的地等控制信息，通过许多交换机和路由器的接力，就可以根据控制信息对这些包进行分拣，然后将它们一步一步地搬运到目的地。</p>
<p>请求和响应的本质都是电信号和光信号，这些信号可能会因受到杂音的干扰而损坏</p>
<p>协议栈：网络控制软件叫协议栈，这个软件会将从浏览器接收到的消息打包，然后加上目的地址等控制信息。还可以在通讯错误时从新打包，调节数据发送速率等，相当于帮我们寄信的小秘书。协议栈会将包交给网卡。</p>
<p>网卡：负责以太网或无线网络通信的硬件。将包转换为电信号并通过网线发送出去。这样包就进入到网络中了。</p>
<p>数据从用来接入互联网的路由器出发进入互联网的内部，互联网的入口线路称为接入网（可以是电话线、ISDN、ADSL、有线电视、光线、专线）。接入网连接到签约的网络运营商，并接入被称为接入点（Point of Presence，PoP）的设备。</p>
<p>接入点的实体是一台专为运营商设计的路由器，相当于离家最近的邮局。</p>
<p>网络包最终到达了Web服务器所在的局域网中。接着，它会遇到防火墙，防火墙对进入的包进行检查。相当于门口的保安，检查包是否危险。检查完后，网络包接下来可能会遇到缓存服务器（网页数据中可以重复利用的数据保存在这里）。若需要访问的数据在缓存服务器中能够找到，那么久不用劳烦Web服务器了，直接从缓存服务器读出数据。</p>
<p>网络包到达Web服务器后，数据会解包并还原原始的请求消息，然后交给Web服务器程序。和客户端一样，这个操作也是由操作系统中的协议栈来完成的。接下来Web服务器分析请求消息的含义，并按照其中的指示将数据装入响应消息中，然后发给客户端，响应消息回到客户端的过程和客户端到服务器的过程正好相反。</p>
<p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/Internet(%E4%BA%8C).png" alt="Aaron Swartz"></p>
<p><img src="" alt="Aaron Swartz"><br>尽管URL有各种不同的写法，但它们有一个共同点，那就是URL开头的文字，即<code>http: ftp: file: mailto:</code>这部分文字都表示浏览器应当使用的访问方法。比如访问Web服务器时应该使用HTTP协议，而访问FTP服务器时则应该使用FTP协议。</p>
<p>URL以”/“结尾时表示后面有文件名被省略了，大多数情况下要访问的是index.html或default.htm之类的</p>
<p>GET：从Web服务器获取网页数据<br>POST：将网页输入框中的信息发送给Web服务器<br>PUT： 从客户端修改Web服务器上的文件<br>DELETE：从客户端删除Web服务器上的文件</p>
<p>请求消息：<br>第一行：请求行，方法（get) URI  HTTP版本。<br>接着：消息头，每行包含一个头字段，用于表示请求的附加信息。<br>空行：<br>最后：消息体，包含客户端向服务器发送的数据</p>
<p>响应消息：<br>第一行：状态行，HTTP版本，状态码，响应短语<br>接着：消息头<br>空行：<br>最后：消息体，包含服务器向客户端发送的数据</p>
<p>###1.2<br>尽管浏览器能够解析网址并生成HTTP消息，但它本身并不具备将消息发送到网络中的功能，因此这一功能需要委托操作系统来实现。在委托操作系统发送消息时，必须要提供的不是通信对象的域名，而是它的IP地址。</p>
<p>互联网和公司内部的局域网都是基于TCP/IP的思路来设计的。TCP/IP就是由一些小的子网，通过路由器连接起来组成一个大的网络。这里的子网可以理解为用集线器连接起来的几台计算机。将子网通过路由器连接起来，就形成了一个网络。</p>
<p>子网掩码是一串长度为32的比特数字，其中左边一半都是1，右边一半都是0。其中为1的部分表示网络号，为0的部分表示主机号</p>
<p>收发数据的操作分为若干阶段，大致总结为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建套接字（创建套接字阶段）</span><br><span class="line">将管道链接到服务器端的套接字上（连接阶段）</span><br><span class="line">收发数据（通信阶段）</span><br><span class="line">断开管道并删除套接字（断开阶段）</span><br></pre></td></tr></table></figure>
<p>同一台计算机上可能出现多个套接字，用描述符识别某个特定的套接字</p>
<p>创建套接字后，需要委托协议栈将客户端创建的套接字与服务器的套接字相连。应用程序通过调用Socket库中的名为connect的程序组件来完成这一操作，connect需要指定描述符、服务器IP地址和端口号3个参数。</p>
<p>描述符时用来在一台计算机内部识别套接字的机制，端口号是用来让通信的另一方能够识别出套接字的机制。</p>
<p>##2<br>###2.1<br>操作系统中的网络控制软件（协议栈）和网络硬件（网卡）将浏览器的消息发送给服务器。</p>
<p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/Internet(12).png" alt="Aaron Swartz"></p>
<p>最上面是网络应用程序，它们会把收发数据等工作委派给下层的部分来完成。接着是Socket库，其中包括解析器，解析器用来想DNS服务器发出查询。然后是操作系统内部，包括协议栈。协议栈的上半部分有两块，分别负责用TCP协议收发数据部分和负责用UDP协议收发数据的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器、邮件等一般应用程序收发数据时用TCP,DNS查询等收发较短的控制数据时用UDP。</span><br></pre></td></tr></table></figure>

<p>下面一半是用IP协议控制网络包收发操作部分。互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是IP来负责的。此外，IP中还包括ICMP协议（用于告知网络包传送过程中产生的错误以及各种控制消息）和ARP协议（用于根据IP地址查询相应的以太网MAC地址）。</p>
<p>IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接受的操作。</p>
<p>存放控制信息的内存空间就是套接字的实体。套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议栈是根据套接字中记录的控制信息来工作的</span><br></pre></td></tr></table></figure>

<p>创建套接字时，首先分配一个套接字所需要的内存空间，然后向其中写入初始状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">控制信息大致分为两类：</span><br><span class="line">客户端和服务器相互联络时交换的控制信息。这些字段就是TCP协议的规格中定义的，是固定，在链接、收发、断开等各个阶段中，每次客户端和服务器之间进行通信时，都需要提供这些控制信息。这些信息会被添加在客户端与服务器之间传递的网络包的开头，也被称为头部。（头部中记录的信息）</span><br><span class="line"></span><br><span class="line">还有就是保存在套接字中，用来控制协议栈操作的信息。应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里。（套接字（协议栈的内存空间）中记录的信息）</span><br></pre></td></tr></table></figure>

<p>连接操作的第一步是在TCP模块处创建表示连接控制信息的头部</p>
<p>通过TCP头部中的发送方和接收方端口号可以找到要连接的套接字。</p>
<p>MTU:一个网络包的最大长度，以太网中一般为1500字节<br>MSS:除去头部之后，一个网络包所能容纳的TCP数据的最大长度</p>
<p>###2.4.2删除套接字</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2019/02/11/iOS%E5%93%8D%E5%BA%94%E9%93%BE%EF%BC%88Responder-Chain%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/11/iOS%E5%93%8D%E5%BA%94%E9%93%BE%EF%BC%88Responder-Chain%EF%BC%89/" itemprop="url">iOS响应链（Responder Chain）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-11T10:03:42+08:00">
                2019-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>官网链接点<a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events?language=objc" target="_blank" rel="noopener">这里</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>App使用响应者对象接收和处理事件，响应者对象时任何<code>UIResponder</code>类的实例，UIResponder的常见子类包括<code>UIView</code>、<code>UIViewController</code>和<code>UIApplication</code>。响应者接收到原始事件数据，必须处理或者传递给另一个响应者对象。当你的APP接收到另一个事件时，UIKit自动引导事件到合适的响应者对象，有就是第一响应者。 </p>
<p>不能处理的事件被传递到响应链中，这是APP响应者对象动态配置的。在APP中没有单一的响应链，UIKit定义了默认的规则关于对象如何被传递在一个响应者到另一个响应者，但是你可以重写响应者对象中适当的属性来改变这些规则。</p>
<p>下图是官方文档给出的默认响应链图：<br><img src="https://pan.baidu.com/disk/home?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=#/all?vmode=list&path=%2FblogImage" alt="Aaron Swartz"></p>
<p>若textField不能处理事件，UIKit会将事件传递给textField的父视图UIView对象,接着是Window的根视图（UIView），在根视图中，响应链在将事件指向window之前会转到所属的视图控制器（UIViewcontroller），如果window不能处理事件，UIKit就会将事件传递给UIApplication对象，如果app delegate是UIResponder的一个实例而不是responder链的一部分，事件也可能会传递给app delegate</p>
<h3 id="确定事件的第一响应者"><a href="#确定事件的第一响应者" class="headerlink" title="确定事件的第一响应者"></a>确定事件的第一响应者</h3><p>UIKit基于事件的类型指定一个对象作为第一响应者。事件类型包括：</p>
<table>
<thead>
<tr>
<th>Event type</th>
<th>First responder</th>
</tr>
</thead>
<tbody><tr>
<td>Touch events</td>
<td>The view in which the touch occurred</td>
</tr>
<tr>
<td>Press events</td>
<td>The object that has focus</td>
</tr>
<tr>
<td>Shake-motion events</td>
<td>the object that you(or UIKit) designate</td>
</tr>
<tr>
<td>Remote-control events</td>
<td>The object that you(or UIKit)designate</td>
</tr>
<tr>
<td>Edit menu messages</td>
<td>The object that you(or UIKit) designate</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：与加速度计、螺旋仪和磁力仪相关的运动事件不遵循响应链。相反，Core Motion 直接将这些事件传递给指定的对象， 参照<a href="https://developer.apple.com/library/archive/documentation/Miscellaneous/Conceptual/iPhoneOSTechOverview/CoreServicesLayer/CoreServicesLayer.html#//apple_ref/doc/uid/TP40007898-CH10-SW27" target="_blank" rel="noopener">Core Motion Framework</a></p>
<p>控件直接与它相关的target对象使用action消息通信。当用户与控件交互时，控件调用target对象的action方法，换句话说，控件发送action消息到目标对象。action消息不是事件，但是它依旧能利用响应链。当控件的target对象为nil，UIKit从target对象和响应链走，直到找到一个对象实现了合适的action方法。</p>
<p>如果视图有添加手势识别器，手势识别器接收touch和press事件在视图接收事件之前。如果所有的视图的手势识别器都不能识别它们的手势，这些事件会传递到视图。如果视图也不能处理，UIKit就会将它们传递给响应链，更多信息参考<a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/handling_uikit_gestures?language=objc" target="_blank" rel="noopener">Handling UIKit Gestures</a></p>
<h3 id="确定哪个响应者包好Touch事件"><a href="#确定哪个响应者包好Touch事件" class="headerlink" title="确定哪个响应者包好Touch事件"></a>确定哪个响应者包好Touch事件</h3><p>UIKit使用基于视图的hit-testing来确定touch事件在哪里产生。UIKit将touch位置与视图层级中的视图对象的边界进行比较。UIView的hitTest:withEvent:方法在视图层级中执行，寻找最深的包含指定touch的子视图，这个视图将成为touch事件的第一响应者。</p>
<p><strong>注意</strong>：若touch位置超过视图边界，hitTest:withEvent方法将忽略这个视图和它的所有子视图。结果就是，当视图的clipsToBounds属性为NO，子视图超过视图边界也不会反悔，即使它们包含发生的touch.</p>
<p>当一个touch事件发生时，UIKit创建一个UITouch对象并将其与视图关联。当触摸位置或其他参数改变时，UIKit用新的信息更新相同的UITouch对象。唯一不变的属性是视图。(即使触摸位置移动到原始视图之外，触摸视图属性中的值也不会改变。)当触摸结束时，UIKit释放UITouch对象。</p>
<h3 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h3><p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/%E5%93%8D%E5%BA%94%E9%93%BE%EF%BC%88%E4%BA%8C%EF%BC%89.png" alt="Aaron Swartz"><br>如图，新建项目，并且添加类别<code>UIView+Resonder</code>、类AView、 BView、CView、DView和EView。其中，然后在Main.storyboard中如次布局：<br><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/%E5%93%8D%E5%BA%94%E9%93%BE%EF%BC%88%E4%B8%89%EF%BC%89.png" alt="Aaron Swartz"></p>
<p>类别中代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  UIView+Responder.m</span><br><span class="line">&#x2F;&#x2F;  响应链</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;  Created by Jaylan on 2018&#x2F;10&#x2F;30.</span><br><span class="line">&#x2F;&#x2F;  Copyright © 2018 Jaylan. All rights reserved.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">#import &quot;UIView+Responder.h&quot;</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line">#import &quot;DView.h&quot;</span><br><span class="line">#import &quot;CView.h&quot;</span><br><span class="line">#import &quot;AView.h&quot;</span><br><span class="line">#import &quot;BView.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static inline void swizzling_exchangeMethod(Class class,SEL originalSelector,SEL swizzlingSelector) &#123;</span><br><span class="line">    Method originalMethod &#x3D; class_getInstanceMethod(class, originalSelector);</span><br><span class="line">    Method swizzlingMethod &#x3D; class_getInstanceMethod(class, swizzlingSelector);</span><br><span class="line">    </span><br><span class="line">    BOOL success &#x3D; class_addMethod(class, originalSelector, method_getImplementation(swizzlingMethod), method_getTypeEncoding(swizzlingMethod));</span><br><span class="line">    if (success) &#123;</span><br><span class="line">        class_replaceMethod(class, swizzlingSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzlingMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation UIView (Responder)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        swizzling_exchangeMethod([UIView class], @selector(touchesBegan:withEvent:), @selector(ds_touchesBegan:withEvent:));</span><br><span class="line">        swizzling_exchangeMethod([UIView class],@selector(touchesMoved:withEvent:), @selector(ds_touchesMoved:withEvent:));</span><br><span class="line">        swizzling_exchangeMethod([UIView class], @selector(touchesEnded:withEvent:), @selector(ds_touchesEnded:withEvent:));</span><br><span class="line"></span><br><span class="line">        swizzling_exchangeMethod([UIView class], @selector(hitTest:withEvent:), @selector(ds_hitTest:withEvent:));</span><br><span class="line">        swizzling_exchangeMethod([UIView class], @selector(pointInside:withEvent:), @selector(ds_pointInside:withEvent:));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark-- 视图替换的方法</span><br><span class="line">- (void)ds_touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;%@ touch begin&quot;, self.class);</span><br><span class="line">    UIResponder *next &#x3D; [self nextResponder];</span><br><span class="line">    while (next) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;,next.class);</span><br><span class="line">        next &#x3D; [next nextResponder];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ds_touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;%@ touch move&quot;,self.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ds_touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    NSLog(@&quot;%@ touch end&quot;, self.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;模拟</span><br><span class="line">- (UIView *)ds_hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &lt; 0.01) &#123;</span><br><span class="line">        return  nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CGRect touch &#x3D; self.bounds;</span><br><span class="line">&#x2F;&#x2F;    if ([self isKindOfClass:CView.class]) &#123;</span><br><span class="line">&#x2F;&#x2F;        touch &#x3D; CGRectInset(self.bounds, -30, -30);&#x2F;&#x2F;都可以增大响应面积</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line"></span><br><span class="line">    if (CGRectContainsPoint(touch, point)) &#123;&#x2F;&#x2F;[self pointInside:point withEvent:event]</span><br><span class="line">        &#x2F;&#x2F;逆序遍历，在subViews后面的先</span><br><span class="line">        for (UIView *subView in [self.subviews reverseObjectEnumerator]) &#123;</span><br><span class="line">            CGPoint convertedPoint &#x3D; [subView convertPoint:point fromView:self];</span><br><span class="line"></span><br><span class="line">            UIView *hitTestView &#x3D; [subView hitTest:convertedPoint withEvent:event];</span><br><span class="line">            if (hitTestView) &#123;</span><br><span class="line">                 &#x2F;&#x2F;在这里打印self.class可以看到递归返回的顺序</span><br><span class="line">                return hitTestView;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;这里就是该视图没有子视图了 点在该视图中，所以直接返回本身，上面的hitTestView就是这个。</span><br><span class="line">        NSLog(@&quot;命中的view:%@&quot;,self.class);</span><br><span class="line">        return self;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;&#x2F;&#x2F;点不在本视图中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)ds_pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">    CGRect touchRect &#x3D; self.bounds;</span><br><span class="line">&#x2F;&#x2F;    if ([self isKindOfClass:DView.class]) &#123;</span><br><span class="line">&#x2F;&#x2F;        touchRect &#x3D; CGRectInset(self.bounds, -30, -30);&#x2F;&#x2F;增加view的响应面积</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">    BOOL success &#x3D; CGRectContainsPoint(touchRect, point);</span><br><span class="line">    if (success) &#123;</span><br><span class="line">        NSLog(@&quot;点在%@里&quot;,self.class);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        NSLog(@&quot;点不在%@里&quot;,self.class);</span><br><span class="line">    &#125;</span><br><span class="line">    return success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>其实代码主要是替换了系统的三个方法<code>touchesBegan:withEvent:</code>、<code>hitTest:withEvent:</code>和<code>pointInside:withEvent:</code>，将它们分别替换成对应的<code>ds_</code>版本</p>
<p>首先模仿官方例子，点击CView,控制台输出如下</p>
<p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/%E5%93%8D%E5%BA%94%E9%93%BE%EF%BC%88%E5%9B%9B%EF%BC%89.png" alt="Aaron Swartz"></p>
<p>因为CView不能响应这个点击事件，所以一直往下传递，最终传递到了APPDelegate。那么如果给AView添加一个单击手势可以看看输出，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UITapGestureRecognizer *cTap &#x3D; [[UITapGestureRecognizer alloc] </span><br><span class="line">initWithTarget:self action:@selector(cTap)]; </span><br><span class="line">[_cView addGestureRecognizer:cTap];</span><br><span class="line"></span><br><span class="line">- (void)cTap &#123;</span><br><span class="line">    NSLog(@&quot;cView tap&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且将<code>ds_hitTest:withEvent：</code>函数里面的<code>CGRectContainsPoint(touch, point)</code>换成<code>[self pointInside:point withEvent:event]</code>再次运行，点击CView，</p>
<p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/%E5%93%8D%E5%BA%94%E9%93%BE%EF%BC%88%E4%BA%94%EF%BC%89.png" alt="Aaron Swartz"></p>
<p>可以看到hitTest:withEvent是从下（UIWindow）往上查找，并且先查找后添加进改视图的（BView和DView都是AView的子视图，可是BView比DView先添加到BView中，查找的时候先查找DView）<br>图中的1我也不知道是啥，感觉像导航栏；2应该是hitTest:withEvent查找顺序了；3是事件的传递顺序。当然这是我的理解（可能和有些博客里面说的不一样）</p>
<p>同时可以看出手势识别的优先级比视图的响应事件高，当然最高的还是action事件（这个有兴趣的可以验证下）</p>
<h3 id="hitTest-withEvent"><a href="#hitTest-withEvent" class="headerlink" title="hitTest:withEvent"></a>hitTest:withEvent</h3><p>返回视图层级中最远的包含响应事件点的子视图。这个方法遍历视图层级让每个子视图调用<code>pointInside:withEvent:</code>方法，确定那个子视图应该接受这个touch事件，若<code>pointInside:withEvent:</code>返回Yes，那么就依次遍历子视图，直到找到最前面的子视图，并且该视图包含这个指定的响应点。若不包含，那么其分支视图将会被忽略。很少需要自己调用这个方法，但可以在子视图中重写它去隐藏touch事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意：这个方法忽略以下情况：</span><br><span class="line">视图是隐藏的 hidden &#x3D; YES</span><br><span class="line">用户交互关闭的 userInteractionEnabled &#x3D; NO</span><br><span class="line">透明度小于0.01的 alpha &lt; 0.01</span><br></pre></td></tr></table></figure>
<p>这个方法在确定命中的时候，不考虑视图的内容。因此，即使指定的点位于该视图内容的透明范围，仍然可以返回视图。</p>
<p>点在接收者的范围之外不会被命中，即使它们实际上处于接收者的子视图内。如果当前视图的clipsToBounds属性设置为NO，就可能会导致这种情况（想图中的DView和EView，如果EView是DView的子视图，有部分超出DView，点击超出的部分是不能返回的）</p>
<h3 id="改变响应链"><a href="#改变响应链" class="headerlink" title="改变响应链"></a>改变响应链</h3><p>你可以改变响应链通过重写你的响应对象的nextResponder属性。当你这样做了之后，下一个响应者就是你设置的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1, UIView 如果视图是ViewController的根视图，下一个响应者为ViewController，否者是视图的父视图。</span><br><span class="line">2, UIViewController 如果视图控制器是window的根视图下一个响应者为window对象。如果视图控制器是由另一个视图控制器推出来，那么下一个响应者为正在推出的视图控制器。</span><br><span class="line">3, UIWindow 下一个响应者为UIApplication对象。</span><br><span class="line">4, UIApplication 下一个响应者为app delegate，但是代理应该是UIResponder的一个实例 而不是 UIView,UIViewController或者app对象本身。</span><br></pre></td></tr></table></figure>
<p>其实可以通过更改响应链的函数来达到一些目的，例如可以代码中的注释部分可以通过更改<code>hitTest:withEvent:</code>或者<code>pointInside:withEvent:</code>里面视图的大小从而来增大响应事件的范围，当然还有响应事件拦截（利用查找顺序）</p>
<p>如果觉得看英文效率低，可以参考<a href="https://www.jianshu.com/p/4155c9ffe1a8" target="_blank" rel="noopener">这儿</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2019/01/25/runtime/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/runtime/" itemprop="url">runtime</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T15:53:58+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>runtime的特性主要是消息传递，若消息在对象中找不到，就进行转发，具体实现我们从以下几个方面介绍：</p>
<h3 id="runtime概论"><a href="#runtime概论" class="headerlink" title="runtime概论"></a>runtime概论</h3><p>Objective-C扩展了C语言，并加入了面向对象特性和Smalltalk式的消息传递机制。而这个扩展的核心是一个用C和编译语言写的runtime库。它是Objective—C面向对象和动态机制的基石。</p>
<p>Objective-C是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态地创建类和对象、进行消息传递和转发。理解Objective-C的runtime机制可以帮我们更好的理解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计和技术问题。<br>runtime的<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FRetVal%2Fobjc-runtime">源码</a>，平时的<a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc" target="_blank" rel="noopener">官方API</a>能帮助我们解决不少问题。</p>
<p>高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但OC并不能直接编译成汇编语言，而是先要转写成纯C语言再进行编译和汇编，从OC到C语言的过度就是用runtime来实现的。然而我们呢使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。</p>
<h3 id="runtime消息传递"><a href="#runtime消息传递" class="headerlink" title="runtime消息传递"></a>runtime消息传递</h3><p>一个对象的方法像这样[obj foo],编译器转成消息objc_msgSend(obj,foo)，runtime时执行的流程是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先，obj通过自己的isa指针找到它的类class；</span><br><span class="line">其次，在类class的方法列表(method list)中查找foo方法；</span><br><span class="line">若class中没哟找到，继续往class的superclass中查找；</span><br><span class="line">依次类推，一旦找到这个函数foo，就去执行它的实现IMP</span><br></pre></td></tr></table></figure>
<p>但是这种实现，若每次都需要这样查找到话效率会比较低，所以objc_class中有一个重要成员objc_cache，在找到foo后，将foo的method_name作为key,method_imp作为value给存起来。当再次收到foo消息时，可以直接在cache里找到，避免重复遍历objc_method_list。</p>
<p>objec_msgSend的方法定义如下：</p>
<p><code>OBJC_EXPORT id objc_msgSend(id self, SEL op, ...)</code></p>
<p>下面是对象(object)，类(class)，方法(method)这几个的结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;对象</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;类</span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">&#x2F;&#x2F;方法列表</span><br><span class="line">struct objc_method_list &#123;</span><br><span class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line">    int method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">    &#x2F;* variable length structure *&#x2F;</span><br><span class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#x2F;&#x2F;方法</span><br><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先，找消息的接收对象，然后通过对象的isa找到它的类。</span><br><span class="line">然后，在该类中查找method_list，是否有selector方法</span><br><span class="line">如果没哟找到，就在父类的method_list中查找</span><br><span class="line">依次类推</span><br><span class="line">找到对应的method，执行它的IMP.</span><br><span class="line">转发IMP的return值</span><br></pre></td></tr></table></figure>

<p>概念梳理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类对象（objc_class）</span><br><span class="line">实例（objc_object）</span><br><span class="line">元类（Meta Class）</span><br><span class="line">Method(objc_method)</span><br><span class="line">SEL(objc_selector)</span><br><span class="line">IMP</span><br><span class="line">类缓存（objc_cache）</span><br><span class="line">Category(objc_category)</span><br></pre></td></tr></table></figure>

<h5 id="类对象（objc-class）"><a href="#类对象（objc-class）" class="headerlink" title="类对象（objc_class）"></a>类对象（objc_class）</h5><p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。</p>
<p><code>typedef struct objc_class *class</code></p>
<p><code>struct objc_class</code>结构体的结构代码在上面已经给出，通过命名发现，保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等。这个类对象的结构体存放的数据称为元数据（metadata），该结构体的第一个成员变量时isa指针，class本身也是一个对象，因此称之为类对象，类对象，类对象在编译期产生用于创建实例对象。同时发现isa指针也是一个<code>objc_class</code>结构体</p>
<h5 id="实例（objc-object）"><a href="#实例（objc-object）" class="headerlink" title="实例（objc_object）"></a>实例（objc_object）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; Represents an instance of a class.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>

<p>类对象中的元数据存储的都是如何创建一个实例的相关信息，类对象和类方法应该是从哪创建的呢？就是从isa执针指向的结构体创建的，类对象的isa指针指向的我们称之为元类（metaclass），元类中保存了创建类对象以及类方法所需要的所有信息，它们的结构如下：</p>
<p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/isa%26superclass%E6%8C%87%E9%92%88%E5%9B%BE.png" alt="Aaron Swartz"></p>
<p>这是一张非常经典而且很有意思的图，图中存在两种箭头，实线指向的是superclass(父类)，虚线是isa指针的指向（也是方法消息传递的指向），从图中我们可以看出，实例对象的isa指向该对象所属的类（例如：Subclass的对象的isa指针指向的是subclass对象），类对象的isa指针指向的是它的元类（下面会讲）。子类的元类和父类的元类之间存在继承关系，但是子类的元类的isa和父类的元类的isa指针同时指向的是基类（root class）的元类，同样基类的isa也是也是指向基类的元类，基类的superclass指向的是nil，比较有意思的是基类的元类的superclass指向的是基类。</p>
<h5 id="元类（Meta-class）"><a href="#元类（Meta-class）" class="headerlink" title="元类（Meta class）"></a>元类（Meta class）</h5><p>元类是一个类对象的类。所有的类自身也是一个对象，我们可以向这个对象发送消息，为了调用类方法，这个类的isa指针必须得指向一个包含这些类方法的一个objc_class结构体，所以就有了metaclass，元类中保存了创建类对象以及类方法所需的所有信息。</p>
<h5 id="Method-objc-method"><a href="#Method-objc-method" class="headerlink" title="Method(objc_method)"></a>Method(objc_method)</h5><p>method和我们平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码。</p>
<p>通过上面的结构体我们可以知道，objc_method包含以下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SEL method_name &#x2F;&#x2F;方法名</span><br><span class="line">char *method_types &#x2F;&#x2F;方法类型</span><br><span class="line">IMP method_imp &#x2F;&#x2F;方法实现</span><br></pre></td></tr></table></figure>
<p>从结构体中，可以看出SEL和IMP都是Method的属性。</p>
<h5 id="SEL-objc-selector"><a href="#SEL-objc-selector" class="headerlink" title="SEL(objc_selector)"></a>SEL(objc_selector)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Objc.h</span><br><span class="line">&#x2F;&#x2F;&#x2F; An opaque type that represents a method selector.代表一个方法的不透明类型</span><br><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>objc_msgSend函数的第二个参数类型是SEL，它是selector在Objective-C中的表示类型。selector是方法选择器，可以理解为区分方法的ID,而这个ID的数据结构体SEL:</p>
<p><code>@property SEL selector;</code></p>
<p>可以看到selector是SEL的一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A method selector is a C string that has been registered (or “mapped“) with</span><br><span class="line">the Objective-C runtime. Selectors generated by the compiler are </span><br><span class="line">automatically mapped by the runtime when the class is loaded.</span><br></pre></td></tr></table></figure>
<p>其实selector就是一个映射到方法的C字符串，可以用Objective-C编译命令@selector()或者Runtime系统的sel_registerName函数来获取一个SEL类型的方法选择器。<br>selector既然是一个string，那么应该类似classname+method的组合，存在如下命名规则:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1，同一个类中，selector不能重复</span><br><span class="line">2，不同的类，selector可以重复</span><br></pre></td></tr></table></figure>
<p>这就使得Objective-C中不能出现函数重载（函数名相同、参数不同），因为selector只记下了method的name，没有参数，所有没法区分。</p>
<h5 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; A pointer to the function of a method implementation.  指向一个方法实现的指针</span><br><span class="line">typedef id (*IMP)(id, SEL, ...); </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>就是指向最终实现程序的内存地址的指针。<br>在iOS的Runtime中，Method通过selector和IMP两个属性实现了快速查询方法及实现，既提高了性能，又保持了灵活性。</p>
<h5 id="类缓存（objc-cache）"><a href="#类缓存（objc-cache）" class="headerlink" title="类缓存（objc_cache）"></a>类缓存（objc_cache）</h5><p>当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象，它可以找到一个实现许多方法的对象。然而你可能只调用了一小部分，并且每次查找时，搜索所有的选择器的类分派表没有意义。所以类实现了一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的的缓存。所以当objc_msgSend查找一个类的选择器，它首先搜索类缓存。</p>
<p>为了加速消息分发，系统会对方法和对应的地址进行缓存，，所以在实际运行中，大部分常用的方法都是会被缓存的，Runtime系统实际上是非常快的，接近直接执行内存地址的程序速度。</p>
<h5 id="Category（objc-category）"><a href="#Category（objc-category）" class="headerlink" title="Category（objc_category）"></a>Category（objc_category）</h5><p>Category是表示一个指向分类的结构体的指针，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123; </span><br><span class="line">    const char *name; 			&#x2F;&#x2F;是指class_name 而不是category_name</span><br><span class="line">    classref_t cls; 			&#x2F;&#x2F;要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到对应的类对象</span><br><span class="line">    struct method_list_t *instanceMethods; &#x2F;&#x2F;category中所有给类添加的实例方法的列表</span><br><span class="line">    struct method_list_t *classMethods; &#x2F;&#x2F;category中所有添加的类方法的列表</span><br><span class="line">    struct protocol_list_t *protocols;	&#x2F;&#x2F;category实现的所有协议的列表</span><br><span class="line">    struct property_list_t *instanceProperties; &#x2F;&#x2F;表示category里所有的properties，这里可以通过objc_setAssociatedObject和objc_getAssociatedObject增加</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的category_t结构体中可以看出，分类可以添加实例方法、类方法，甚至可以实现协议，添加属性，不可以添加成员变量</p>
<h3 id="Runtime消息转发"><a href="#Runtime消息转发" class="headerlink" title="Runtime消息转发"></a>Runtime消息转发</h3><p>上面介绍过，进行一次发送消息会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上搜索直到继承树的根部（通常为NSObject）,（先通过对象的isa指针找到对象所属的类，然后从该类的方法列表中查找，若没有找到，就从该类的父类的方法列表中查找）。若最终还是没找到就执行doesNotRecognizeSelector:方法报unrecognized Selector。那么消息转发到底是什么呢？接下来会介绍报错前的最后三次机会。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动态方法解析</span><br><span class="line">备用接收者</span><br><span class="line">完整消息转发</span><br></pre></td></tr></table></figure>

<h4 id="方法动态解析"><a href="#方法动态解析" class="headerlink" title="方法动态解析"></a>方法动态解析</h4><p>首先，Objective-C运行时会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>让开发者有机会给SEL方法动态提供一个实现，如果添加了，并且返回YES，那运行时系统就会重新启动一次消息发送的过程。<br>下面看代码实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  UILabel+DefaultColor.h</span><br><span class="line">@interface UILabel (DefaultColor)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UIColor *defaultColor;</span><br><span class="line"></span><br><span class="line">- (void)updateColor;</span><br><span class="line">+ (void)update;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  UILabel+DefaultColor.m</span><br><span class="line">#import &quot;UILabel+DefaultColor.h&quot;</span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation UILabel (DefaultColor)</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> 为实例方法的sel动态提供实现</span><br><span class="line"> @param sel &lt;#sel description#&gt;</span><br><span class="line"> @return &lt;#return value description#&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(updateColor)) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         添加方法</span><br><span class="line"></span><br><span class="line">         class_addMethod(Class _Nullable cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)</span><br><span class="line">         cls:被添加方法的类</span><br><span class="line">         name: 被添加方法的名称的SEL</span><br><span class="line">         imp:方法的实现</span><br><span class="line">         types:方法的类型</span><br><span class="line">         *&#x2F;</span><br><span class="line">        class_addMethod(self.class, sel, class_getMethodImplementation([self class], @selector(ds_updateColor)), nil);</span><br><span class="line">        return YES;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return  [super resolveInstanceMethod:sel];</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)ds_updateColor &#123;</span><br><span class="line">    NSLog(@&quot;this is updateColor&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br></pre></td></tr></table></figure>
<p>上述代码，新建一个UILabel的分类DefaultColor，声明一个方法<code>updateColor</code>但是没有提供实现，<br>在实现文件中重写了<code>resolveInstanceMethod:</code>方法，并且当sel为updateColor时给它添加了实现方法。打印的结果为：</p>
<p><code>2019-01-28 14:53:23.584822+0800 runtime[2299:597816] this is updateColor</code></p>
<p>可以看出虽然没有给updateColor提供实现，但是通过class_addMethod动态添加ds_updateColor函数，并执行updateColor这个函数的IMP。从打印结果发现成功了。<br>如果返回NO呢，发现还是会执行ds_updateColor方法，并且也不会执行下面的<code>forwardingTargetForSelector:</code>，只有当<code>dis_updateColor</code>没有实现时，才会执行<code>forwardingTargetForSelector:</code>(和好多博客写的都不一样，看来实验是检验真理的唯一标准。其实通过好多验证，我发现有的知识点和博客上写的不一样，和我想象的也不太一样)。</p>
<h4 id="备用接收者"><a href="#备用接收者" class="headerlink" title="备用接收者"></a>备用接收者</h4><p>若目标对象实现了-forwardingTargetForSelector:，Runtime调用了这个方法，就有机会把这个消息转发给其他对象。<br>代码走起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先调用resolveInstanceMethod函数，如果没有找到函数，就调用这个函数找到了就会调用person里面的updateColor</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(updateColor)) &#123;</span><br><span class="line">        return [Person new];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的分类里面添加上面这段代码，并且要注释掉方法ds_updateColor方法，然后，在Person类里面添加updateColor的实现（可以没有声明），运行代码，会发现会执行Person类里面的updateColor方法打印出<code>2019-01-28 15:44:58.907483+0800 runtime[3108:735687] update of person</code></p>
<p>会发现<code>forwardingTargetForSelector</code>把UILabel分类的方法转给了Person实例执行。</p>
<h4 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h4><p>继续玩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">&#x2F;&#x2F;    NSMethodSignature *methodSignature &#x3D; [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#x2F;&#x2F;    if (!methodSignature) &#123;</span><br><span class="line">&#x2F;&#x2F;        methodSignature &#x3D; [[Person new] methodSignatureForSelector:aSelector];</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">&#x2F;&#x2F;    return methodSignature;</span><br><span class="line">    if (aSelector &#x3D;&#x3D; @selector(updateColor)) &#123;</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">&#x2F;&#x2F;    if ([[Person new] respondsToSelector:[anInvocation selector]]) &#123;</span><br><span class="line">&#x2F;&#x2F;        [anInvocation invokeWithTarget:[Person new]];</span><br><span class="line">&#x2F;&#x2F;    &#125;else &#123;</span><br><span class="line">&#x2F;&#x2F;        [super forwardInvocation:anInvocation];</span><br><span class="line">&#x2F;&#x2F;    &#125;</span><br><span class="line">    if (anInvocation.selector &#x3D;&#x3D; @selector(updateColor)) &#123;</span><br><span class="line">        void *argBuf &#x3D; NULL;</span><br><span class="line">        NSUInteger numberOfArguments &#x3D; anInvocation.methodSignature.numberOfArguments;</span><br><span class="line">        for (NSUInteger idx &#x3D; 2; idx &lt; numberOfArguments; idx ++) &#123;</span><br><span class="line">            const char *type &#x3D; [anInvocation.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">            NSUInteger argSize;</span><br><span class="line">            NSGetSizeAndAlignment(type, &amp;argSize, NULL);</span><br><span class="line">            if (!(argBuf &#x3D; reallocf(argBuf, argSize))) &#123;</span><br><span class="line">                NSLog(@&quot;failed to allocate memory for block invocation&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            [anInvocation getArgument:argBuf atIndex:idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doesNotRecognizeSelector:(SEL)aSelector &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加上述代码，将forwardingTargetForSelector里面的<code>return [Person new]</code>去掉再次运行，你会发现会执<code>methodSignatureForSelector:</code>方法，当返回nil时，会直接执行<code>doesNotRecognizeSelector:</code>方法，否则，会执行<code>forwardInvocation:</code>,可以让Person对象去执行updateColor方法。签名参数见<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a></p>
<p>那么消息转发流程图为  </p>
<p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B%E7%AE%80%E5%9B%BE%20(1).jpg" alt="Aaron Swartz"></p>
<h4 id="Runtime应用"><a href="#Runtime应用" class="headerlink" title="Runtime应用"></a>Runtime应用</h4><p>Runtime消息转发机制说清楚了，我们可以知道几乎所有的操作都会用消息发送，可见是是国之利器，用得好利国利民，用不好，一步一崩溃。那么看看常见的应用场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关联对象（Objective-C Associated Objects）给分类增加属性</span><br><span class="line">方法魔法（Method Swizzling）方法添加和方法替换和KVO实现</span><br><span class="line">消息转发（热更新）解决bug(JSPatch)</span><br><span class="line">实现NSCoding的自动归档和自动解档</span><br><span class="line">实现字典和模式的自动转换（MJExtension）</span><br></pre></td></tr></table></figure>

<h5 id="关联对象（Objective-C-Associated-Objects）给分类增加属性"><a href="#关联对象（Objective-C-Associated-Objects）给分类增加属性" class="headerlink" title="关联对象（Objective-C Associated Objects）给分类增加属性"></a>关联对象（Objective-C Associated Objects）给分类增加属性</h5><p>我们都知道分类是不能自定义属性和变量的。下面通过关联对象实现给分类添加属性。</p>
<p>同样，代码走起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  UILabel+DefaultColor.h</span><br><span class="line">@property (nonatomic, strong) UIColor *defaultColor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  UILabel+DefaultColor.m</span><br><span class="line">static char kDefaultColorKey;&#x2F;&#x2F;只有第一次能被初始化，或编译器自动赋值</span><br><span class="line"></span><br><span class="line">- (void)setDefaultColor:(UIColor *)defaultColor &#123;</span><br><span class="line">    objc_setAssociatedObject(self, &amp;kDefaultColorKey, defaultColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    NSLog(@&quot;--%s&quot;,&amp;kDefaultColorKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIColor *)defaultColor &#123;</span><br><span class="line">   return objc_getAssociatedObject(self, &amp;kDefaultColorKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  ViewController.m</span><br><span class="line">label.defaultColor &#x3D; [UIColor redColor];</span><br><span class="line">NSLog(@&quot;label-%@&quot;,label.defaultColor);</span><br></pre></td></tr></table></figure>
<p>在三个地方添加的代码如上所述，最后输出<code>2019-01-28 16:58:21.604855+0800 runtime[4289:914361] label-UIExtendedSRGBColorSpace 1 0 0 1</code>可知添加属性成功。</p>
<h4 id="方法魔法（Method-Swizzling）方法添加和方法替换和KVO实现"><a href="#方法魔法（Method-Swizzling）方法添加和方法替换和KVO实现" class="headerlink" title="方法魔法（Method Swizzling）方法添加和方法替换和KVO实现"></a>方法魔法（Method Swizzling）方法添加和方法替换和KVO实现</h4><p>在将这两个之前先介绍两个特殊的方法，<code>+ (void)load</code>和<code>+（void）initialize</code>，在Objective-C的运行时中，每个类都有这两个方法的自动调用。<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load?language=objc" target="_blank" rel="noopener"><code>load</code></a>是一个类在初始装载时调用，<a href="https://developer.apple.com/documentation/objectivec/nsobject/1418639-initialize?language=objc" target="_blank" rel="noopener"><code>initialize</code></a>是在应用第一次调用该类的类方法或实例方法前调用，两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。</p>
<p>swizzling应该只在dispatch_once中完成</p>
<p>由于swizzling改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。dispatch_once满足了所需要的需求，并且应该被当做使用swizzling的初始化单例方法的标准。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">static inline void swizziling_exchangeMethod(Class class, SEL originalSelector, SEL swizzileSelector) &#123;</span><br><span class="line">    &#x2F;&#x2F;   获取类的实例方法</span><br><span class="line">    Method originalMethod &#x3D; class_getInstanceMethod(class, originalSelector);</span><br><span class="line">    Method swizzleMethod &#x3D; class_getInstanceMethod(class, swizzileSelector);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;    添加一个方法，并且将其实现与指定的sel相对应</span><br><span class="line">    BOOL success &#x3D; class_addMethod(class, originalSelector, class_getMethodImplementation(class, swizzileSelector), method_getTypeEncoding(swizzleMethod));</span><br><span class="line">    if (success) &#123;</span><br><span class="line">        class_replaceMethod(class, swizzileSelector, class_getMethodImplementation(class, originalSelector), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzleMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">     类在初始装载时调用</span><br><span class="line">     *&#x2F;</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        &#x2F;&#x2F;交换一次输出ds_,再次交换输出viewWillAppear</span><br><span class="line">        swizziling_exchangeMethod(self, @selector(viewWillAppear:), @selector(ds_viewWillAppear:));</span><br><span class="line">&#x2F;&#x2F;        swizziling_exchangeMethod(self, @selector(viewWillAppear:), @selector(ds_viewWillAppear:));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;this is viewWillAppear&quot;);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">- (void)ds_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;this is ds_viewWillAppear&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ViewController里面添加如上代码，运行，打印出</p>
<p><code>2019-01-28 17:48:18.132592+0800 runtime[4967:1009860] this is ds_viewWillAppear</code>，</p>
<p>然后去掉load方法另一个行代码的注释，再次运行打印出</p>
<p><code>2019-01-28 17:50:05.848961+0800 runtime[5012:1015766] this is viewWillAppear</code></p>
<p>可以看出第一运行时将两个方法的IMP交换了，第二次调用<code>swizziling_exchangeMethod</code>方法时又将它们交换回来了，所以打印的结果和什么都没有做是一样的。</p>
<p>至于KVO,就不在此处再次验证了，以前的博客里面有<a href="">KVC&amp;KVO</a></p>
<h4 id="消息转发-热更新-解决Bug-JSPatch"><a href="#消息转发-热更新-解决Bug-JSPatch" class="headerlink" title="消息转发(热更新)解决Bug(JSPatch)"></a>消息转发(热更新)解决Bug(JSPatch)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSPatch 是一个 iOS 动态更新框架，只需在项目中引入极小的引擎，就可以使用 JavaScript 调用任何 Objective-C 原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复 bug。</span><br></pre></td></tr></table></figure>
<p>关于消息转发，前面已经讲到过了，消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fbang590%2FJSPatch%2Fwiki%2FJSPatch-%25E5%25AE%259E%25E7%258E%25B0%25E5%258E%259F%25E7%2590%2586%25E8%25AF%25A6%25E8%25A7%25A3">JSPatch</a>不仅能够实现消息转发，还可以实现方法添加、替换能一系列功能。</p>
<h4 id="实现NSCoding的自动归档和自动解档"><a href="#实现NSCoding的自动归档和自动解档" class="headerlink" title="实现NSCoding的自动归档和自动解档"></a>实现NSCoding的自动归档和自动解档</h4><p>原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。 核心方法：在Model的基类中重写方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解码</span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)coder</span><br><span class="line">&#123;</span><br><span class="line">    Class cls &#x3D; self.class;</span><br><span class="line">    while (cls !&#x3D; NSObject.class) &#123;</span><br><span class="line">        BOOL kIsSelfClass &#x3D; cls &#x3D;&#x3D; self.class;</span><br><span class="line">        unsigned int ivarCount &#x3D; 0;</span><br><span class="line">        unsigned int propVarCount &#x3D; 0;</span><br><span class="line">        unsigned int shareVarCount &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">        Ivar *ivars &#x3D; kIsSelfClass ? class_copyIvarList(cls, &amp;ivarCount) : NULL;</span><br><span class="line">        objc_property_t *propList &#x3D; kIsSelfClass ? NULL : class_copyPropertyList(cls, &amp;propVarCount);</span><br><span class="line">        shareVarCount &#x3D; ivarCount + propVarCount;</span><br><span class="line">        for (NSInteger idx &#x3D; 0; idx&lt;shareVarCount; idx ++) &#123;</span><br><span class="line">            const char *varName &#x3D; kIsSelfClass ? ivar_getName(*(ivars + idx)) : property_getName(*(propList + idx));</span><br><span class="line">            NSString *key &#x3D; [NSString stringWithUTF8String:varName];</span><br><span class="line">            </span><br><span class="line">            id value &#x3D; [coder decodeObjectForKey:key];</span><br><span class="line">            NSArray *filter &#x3D; @[@&quot;superclass&quot;,@&quot;description&quot;,@&quot;debugDescription&quot;,@&quot;hash&quot;];</span><br><span class="line">            if (value &amp;&amp; [filter containsObject:key] &#x3D;&#x3D; NO) &#123;</span><br><span class="line">                [self setValue:value forKey:key];</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);</span><br><span class="line">        free(propList);</span><br><span class="line">        cls &#x3D; class_getSuperclass(cls);</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;编码</span><br><span class="line">- (void)encodeWithCoder:(nonnull NSCoder *)aCoder &#123;</span><br><span class="line">    </span><br><span class="line">    Class cls &#x3D; self.class;</span><br><span class="line">    while (cls !&#x3D; NSObject.class) &#123;</span><br><span class="line">        BOOL kIsSelfClass &#x3D; cls &#x3D;&#x3D; self.class;</span><br><span class="line">        unsigned int ivarCount &#x3D; 0;</span><br><span class="line">        unsigned int propVarCount &#x3D; 0;</span><br><span class="line">        unsigned int shareVarCount &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">        Ivar *ivars &#x3D; kIsSelfClass ? class_copyIvarList(cls, &amp;ivarCount) : NULL;</span><br><span class="line">        objc_property_t *propList &#x3D; kIsSelfClass ? NULL : class_copyPropertyList(cls, &amp;propVarCount);</span><br><span class="line">        shareVarCount &#x3D; ivarCount + propVarCount;</span><br><span class="line">        for (NSInteger idx &#x3D; 0; idx&lt;shareVarCount; idx ++) &#123;</span><br><span class="line">            const char * varName &#x3D; kIsSelfClass ? ivar_getName(*(ivars + idx)) : property_getName(*(propList + idx));</span><br><span class="line">            NSString *key &#x3D; [NSString stringWithUTF8String:varName];</span><br><span class="line">            </span><br><span class="line">            id value &#x3D; [self valueForKey:key];</span><br><span class="line">            NSArray *filter &#x3D; @[@&quot;superclass&quot;,@&quot;description&quot;,@&quot;debugDescription&quot;,@&quot;hash&quot;];</span><br><span class="line">            if (value &amp;&amp; [filter containsObject:key] &#x3D;&#x3D; NO) &#123;</span><br><span class="line">                [aCoder encodeObject:value forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        free(ivars);</span><br><span class="line">        free(propList);</span><br><span class="line">        cls &#x3D; class_getSuperclass(cls);&#x2F;&#x2F;指向当前类的父类</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现字典和模型的自动转换-MJExtension"><a href="#实现字典和模型的自动转换-MJExtension" class="headerlink" title="实现字典和模型的自动转换(MJExtension)"></a>实现字典和模型的自动转换(MJExtension)</h4><p>原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。 核心方法：在NSObject的分类中添加方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithDict:(NSDictionary *)dict &#123;</span><br><span class="line"></span><br><span class="line">    if (self &#x3D; [self init]) &#123;</span><br><span class="line">        &#x2F;&#x2F;(1)获取类的属性及属性对应的类型</span><br><span class="line">        NSMutableArray * keys &#x3D; [NSMutableArray array];</span><br><span class="line">        NSMutableArray * attributes &#x3D; [NSMutableArray array];</span><br><span class="line">        &#x2F;*</span><br><span class="line">         * 例子</span><br><span class="line">         * name &#x3D; value3 attribute &#x3D; T@&quot;NSString&quot;,C,N,V_value3</span><br><span class="line">         * name &#x3D; value4 attribute &#x3D; T^i,N,V_value4</span><br><span class="line">         *&#x2F;</span><br><span class="line">        unsigned int outCount;</span><br><span class="line">        objc_property_t * properties &#x3D; class_copyPropertyList([self class], &amp;outCount);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; outCount; i ++) &#123;</span><br><span class="line">            objc_property_t property &#x3D; properties[i];</span><br><span class="line">            &#x2F;&#x2F;通过property_getName函数获得属性的名字</span><br><span class="line">            NSString * propertyName &#x3D; [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding];</span><br><span class="line">            [keys addObject:propertyName];</span><br><span class="line">            &#x2F;&#x2F;通过property_getAttributes函数可以获得属性的名字和@encode编码</span><br><span class="line">            NSString * propertyAttribute &#x3D; [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding];</span><br><span class="line">            [attributes addObject:propertyAttribute];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;立即释放properties指向的内存</span><br><span class="line">        free(properties);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;(2)根据类型给属性赋值</span><br><span class="line">        for (NSString * key in keys) &#123;</span><br><span class="line">            if ([dict valueForKey:key] &#x3D;&#x3D; nil) continue;</span><br><span class="line">            [self setValue:[dict valueForKey:key] forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有的人可能会会发现我的博客和很多其他博客相像，或者说很多雷同，我不否认只一点，这篇博客参考<a href="https://juejin.im/post/5ac0a6116fb9a028de44d717" target="_blank" rel="noopener">iOS Runtime详解</a>，因为我主要是想验证知识点梳理知识点，而不是叙述。其实好多博客都或多或少都有所雷同，甚至错误的点也雷同。该赶车了，回家过年了哦</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2019/01/23/KVC-KVO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/23/KVC-KVO/" itemprop="url">KVC&KVO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-23T16:25:49+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##KVC<br><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html" target="_blank" rel="noopener">官方介绍</a></p>
<p>KVC（简直编码）是由NSKeyValueCoding协议启用的机制，对象采用这种机制提供对其属性的间接访问，这种间接访问机制补充了实例变量及其相关访问器方法提供的直接方法。</p>
<p>KVC是<code>Key Value Coding</code>的简称，它是通过字符串（key）来访问的。<br>KVC比较重要的有一下几个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)valueForKey:(NSString *)key;                          &#x2F;&#x2F;通过Key来取值</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;          &#x2F;&#x2F;通过Key来设值</span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;                  &#x2F;&#x2F;通过KeyPath来取值</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;  &#x2F;&#x2F;通过KeyPath来设值</span><br></pre></td></tr></table></figure>
<p>可以注意下这些方法的value无论是作为返回值还是参数都是id类型<br>还有一些其他的方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)accessInstanceVariablesDirectly;</span><br><span class="line">&#x2F;&#x2F;默认返回YES，表示如果没有找到Set&lt;Key&gt;方法的话，会按照_key，_iskey，key，iskey的顺序搜索成员，设置成NO就不这样搜索</span><br><span class="line"></span><br><span class="line">- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</span><br><span class="line">&#x2F;&#x2F;KVC提供属性值正确性�验证的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。</span><br><span class="line"></span><br><span class="line">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;</span><br><span class="line">&#x2F;&#x2F;这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回。</span><br><span class="line"></span><br><span class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</span><br><span class="line">&#x2F;&#x2F;如果Key不存在，且没有KVC无法搜索到任何和Key有关的字段或者属性，则会调用这个方法，默认是抛出异常。</span><br><span class="line"></span><br><span class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</span><br><span class="line">&#x2F;&#x2F;和上一个方法一样，但这个方法是设值。</span><br><span class="line"></span><br><span class="line">- (void)setNilValueForKey:(NSString *)key;</span><br><span class="line">&#x2F;&#x2F;如果你在SetValue方法时面给Value传nil，则会调用这个方法</span><br><span class="line"></span><br><span class="line">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</span><br><span class="line">&#x2F;&#x2F;输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。</span><br></pre></td></tr></table></figure>
<p>可以参考<a href="https://www.jianshu.com/p/45cbd324ea65" target="_blank" rel="noopener">这儿</a><br>###KVC寻找Key的方式<br>下面的<key>是指成员变量名，首字母大小写要符合KVC的命名规则<br>####写入（设值）<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/SearchImplementation.html#//apple_ref/doc/uid/20000955" target="_blank" rel="noopener">官网</a><br>还是先从代码说起吧，因为有的时候实验的结果和有的博客上面叙述的不一样，和自己想象的也不一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  Person.m</span><br><span class="line">NSString *name;</span><br><span class="line">NSString *isName;</span><br><span class="line">NSString *_name;</span><br><span class="line">NSString *_isName;</span><br><span class="line"></span><br><span class="line">+ (BOOL)accessInstanceVariablesDirectly &#123;</span><br><span class="line">    BOOL returnValue &#x3D; NO;</span><br><span class="line">    </span><br><span class="line">    return returnValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)valueForUndefinedKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;1---该key不存在--%@&quot;,key);</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setValue:(id)value forUndefinedKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;2---该key不存在--%@&quot;,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Person类中声明上面的四个个成员变量，并实现name的setter方法<br><code>- (void)setName: (NSString *)name</code>，然后重写代码中的三个方法，其中<code>accessInstanceVariablesDirectly</code>方法返回NO,最后再ViewController类中调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person *person &#x3D; [[Person alloc] init];</span><br><span class="line">[person setValue:@&quot;Davi&quot; forKey:@&quot;name&quot;];</span><br></pre></td></tr></table></figure>
<p>运行的时候，打断点会发现会执行name的setter方法，也就是说，<code>setValue: forKey:</code>方法先查找setter方法。<br>注释掉setter方法后，因为是成员变量，所以编译器不会像属性那样自动合成对应的访问方法（包括setter方法）。</p>
<p>如此这样那么你会发现执行了<code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>方法，也就是说没有搜到和<code>name</code>有关的成员变量和属性，从而抛出异常。</p>
<p>然后，我们更改代码，让<code>accessInstanceVariablesDirectly</code>返回Yes，再次执行。如此这样那么你会发现Variable View里面如下显示：</p>
<p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/KVC%26KVO%EF%BC%88%E4%B8%80%EF%BC%89.png" alt="Aaron Swartz"></p>
<p>会发现其实这setValue: forKey: 方法是给成员变量_name设置值。</p>
<p>然后注释掉_name成员变量，再次运行，你会发现：</p>
<p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/KVC%26KVO(%E4%BA%8C).png" alt="Aaron Swartz"></p>
<p>会发现其实这时候的setValue: forKey: 方法是给_isName设置值。</p>
<p>然后同样注释掉_isName成员变量，再次运行，得到的是这样的：</p>
<p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/KVC%26KVO(%E4%B8%89).png" alt="Aaron Swartz"></p>
<p>注释掉name，然后就会给isName设置。</p>
<p>接着玩，我们注释掉isName成员变量，打断点发现会执行<code>- (void)setValue:(id)value forUndefinedKey:(NSString *)key</code>方法，也就是说没有搜到和<code>name</code>有关的成员变量和属性，从而抛出异常。</p>
<p>好了，<code>setValue: forKey:</code>玩完了，那么结论是什么？<br>从上面的实验中我们可以得出：</p>
<p>1，<code>setValue: forKey</code>方法开始会查找与key 属性相关的setter方法(看到这儿你是否会想起什么，不错，我原来也没想到，或者说也没有在其他博客上面看到，写到这儿才意识到我们是不是可以尝试下<code>- (void)setIsName: (NSString *)isName</code>这个setter方法，看看它会不会和<code>- (void)setName: (NSString *)name</code>是一样的效果。经过实验，果然会执行该方法，且该方法会在没有搜索到<code>- (void)setName: (NSString *)name</code>方法后调用)。</p>
<p>2，<code>accessInstanceVariablesDirectly</code>方法就像是KVC的开关一样。如果该方法返回的是NO，<code>setValue: forKey:</code>方法只会搜索与key属性相关的setter方法，搜索到就执行，没有搜索到就会直接执行<code>setValue: forUndefinedKey:</code>方法；如果该方法返回YES，那么<code>setValue: forKey:</code>方法在没有所搜到与key属性相关的setter方法时，就会继续搜索想对应的成员变量，顺序依次为<code>_&lt;key&gt;,_is&lt;key&gt;,&lt;key&gt;,is&lt;key&gt;</code>，当都没有搜索到时才会执行<code>setValue: forUndefinedKey:</code></p>
<p>####读取(取值)<br>同样，从代码开始，在Person 类中添加了上述中的代码(不用注释掉成员变量)的同时，还添加一下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)getName &#123;</span><br><span class="line">    return toSetName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return toSetName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (NSString *)isName &#123;</span><br><span class="line">    return toSetName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ViewController中添加代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *name &#x3D; [person valueForKey:@&quot;name&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,name);</span><br></pre></td></tr></table></figure>
<p>执行代码的时候，会发现会调用<code>getName</code>方法，</p>
<p>同样玩法没变，我们注释掉<code>getName</code>方法，再次运行<br>我们会发现调用<code>name</code>方法</p>
<p>再次注释掉<code>name</code>方法，再次运行，会发现调用<code>isName</code>方法</p>
<p>接着我们注释掉<code>isName</code>方法，再次运行（注意此时<code>accessInstanceVariablesDirectly</code>方法返回NO和YES都可）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：当时基本数据类型时，最好封装成Objective-C对象，因为相关方法的参数都是id类型</span><br></pre></td></tr></table></figure>
<p>然后，看着官方介绍敲代码吧（实验室检验真理的唯一标准）</p>
<p>在Person类中添加成员变量<code>NSString *strr;</code>，并且添加三个函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)countOfStrr &#123;</span><br><span class="line">    return 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;下面两个是数组</span><br><span class="line">- (id)objectInStrrAtIndex:(NSInteger)idx &#123;</span><br><span class="line">    </span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">- (id)strrAtIndexes:(NSIndexSet *)indexes &#123;</span><br><span class="line">    return @&quot;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ViewController里面添加代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__unused   NSNumber *nn &#x3D; [person valueForKey:@&quot;strr&quot;];&#x2F;&#x2F;代码1</span><br><span class="line">NSLog(@&quot;%@&quot;,nn);&#x2F;&#x2F;代码2</span><br></pre></td></tr></table></figure>
<p>如此这样，那么我们可以接着玩了(注意，让<code>accessInstanceVariablesDirectly</code>返回YES,否则还是没得玩，直接<code>valueForUndefinedKey:</code>)</p>
<p>会发现会运行函数<code>countOfStrr</code>，细心的人会发现，该函数不是代码1调用的（断点可以证明，当然可以去掉代码2验证，会发现不再调用函数<code>countOfStrr</code>），也就是说如果光执行<code>valueForKey:</code>方法去取值，而不用，是不会调用这个函数的（也可以理解为这时候只在需要用的时候才会以这种方式去取）。</p>
<p>继续运行执行了函数<code>objectInStrrAtIndex:</code>没有执行<code>strrAtIndexes：</code>，当注释掉<code>objectInStrrAtIndex</code>这个函数再次运行时，会发现即使存在<code>strrAtIndexes:</code>会执行，当这两个函数都不存在的时候，程序是不会执行<code>countOfStrr</code>方法的，还可以得出这两个函数的优先级是前者大于后者的。</p>
<p>上面的两个函数的<a href="">方法/函数原型</a>是<code>objectIn&lt;key&gt;AtIndex</code>和<code>&lt;key&gt;AtIndexes</code>这两个函数都是NSArry类里面定义的函数，官网说，只要运行<code>countOf&lt;key&gt;</code>和<code>objectIn&lt;key&gt;AtIndex:</code>、<code>&lt;key&gt;AtIndexs:</code>中的任何一个，那么就会创建一个响应所有集合代理对象，并将之返回。或者说给该集合代理对象发送属于NSArray的方法，就会以上面的三个方法组合的形式调用。可有一个可选的<code>get&lt;key&gt;:rang:</code>方法。</p>
<p>本来关于集合的也想验证下，可是实验没成功（都没运行，不知道是不是函数写错了，反正在api是没有找到相关的函数），本着对官方资料的尊重，还是叙述一遍吧：</p>
<p>若上面的方法还没有找到，那么会同时查找<code>countOf&lt;Key&gt;</code>，<code>enumeratorOf&lt;Key&gt;</code>,<code>memberOf&lt;Key&gt;</code>格式的方法。（实验时感觉是对属性有效，因为属性会自动提示，但还是没有调用）如果三个方法都找到了，那么就返回一个可以响应NSSets方法的代理集合对象，如果像这个集合代理对象发送消息，就会以这三个方法的组合形式调用。</p>
<p>如果还没有找到，再检查<code>accessInstanceVariablesDirectly</code>是否返回YES，如果是那么就会像<code>setValue: ForKey:</code>那样，依次查找<code>_name,_isName,name,isName</code>若没有找到，就会和返回NO一样调用<code>valueForUndefinedKey:</code></p>
<p>####KVC中使用keyPath<br>当对象比较复杂时，例如Person类有一个属性是Address对象，Address有一个city属性，可以直接<code>[person setValue:@&quot;深圳&quot; forKeyPath:@&quot;address.city&quot;];</code>给person对象的属性address的属性city赋值，即使这些属性是私有的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：不能给key传nil, 否则会崩溃， 但是给value传nil 不会崩溃</span><br><span class="line">而给字典的&#96;setObject: forKey:&#96;两个参数都不能传nil，否则会崩溃</span><br></pre></td></tr></table></figure>


<p>##KVO<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177-BCICJDHA" target="_blank" rel="noopener">官网</a><br>KVO是Key-value observing的简称，在对象的属性被改变的时候允许给其他对象发送消息。今天主要探索的是KVO的底层实现，所以还是从代码开始。<br>在Person类中添加一个age属性，并且添加如下方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)setAge:(NSUInteger)age &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">    _age &#x3D; age;</span><br><span class="line">    [self didChangeValueForKey:@&quot;age&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)willChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    [super willChangeValueForKey:key];</span><br><span class="line">    NSLog(@&quot;willChangeValueForKey&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key &#123;</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey-begin&quot;);</span><br><span class="line">    [super didChangeValueForKey:key];</span><br><span class="line">    NSLog(@&quot;didChangeValueForKey-end&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不允许自动发送通知</span><br><span class="line">+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ViewController里面添加下面这些代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">self.person1 &#x3D; [Person new];</span><br><span class="line">    self.person2 &#x3D; [Person new];</span><br><span class="line">    self.person1.age &#x3D; self.person2.age &#x3D; 5;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;打印方法的实现,会发现person1的setAge：方法的实现的地址变了</span><br><span class="line">    NSLog(@&quot;监听之前--person1:%p,--person2:%p&quot;,[self.person1 methodForSelector:@selector(setAge:)],[self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class="line">    &#x2F;&#x2F;前后打印相同，应该是NSKVONotifying_Person类重写了class方法</span><br><span class="line">    NSLog(@&quot;%@--%@&quot;,[self.person1 class],[self.person2 class]);</span><br><span class="line">    &#x2F;&#x2F;执行这一句后self.person1.isa指向由Person变成NSKVONotifying_PersonP</span><br><span class="line">    [self.person1 addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">    &#x2F;&#x2F;把地址强转IMP打印出来后</span><br><span class="line">    &#x2F;**</span><br><span class="line">     (lldb) p (IMP)0x10d634552</span><br><span class="line">     (IMP) $0 &#x3D; 0x000000010d634552 (Foundation&#96;_NSSetUnsignedLongLongValueAndNotify)</span><br><span class="line">     (lldb) p (IMP)0x10d2d9150</span><br><span class="line">     (IMP) $1 &#x3D; 0x000000010d2d9150 (KVC&amp;KVO&#96;-[Person setAge:] at Person.h:17)</span><br><span class="line">     可以看出person2的setAge:没有发生变化，而person1变成了_NSSetUnsignedLongLongValueAndNotify的C函数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    NSLog(@&quot;监听之后--person1:%p,--person2:%p&quot;,[self.person1 methodForSelector:@selector(setAge:)],[self.person2 methodForSelector:@selector(setAge:)]);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;也可以这样打印所对应的类对象</span><br><span class="line">    NSLog(@&quot;claseObject-%s--%s&quot;,object_getClassName(self.person1),object_getClassName(self.person2));</span><br><span class="line">    NSLog(@&quot;%@--%@&quot;,[self.person1 class],[self.person2 class]);</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F;    2018-10-30 20:31:33.586610+0800 KVC&amp;KVO[31665:677189] 方法名---setAge:</span><br><span class="line">&#x2F;&#x2F;    2018-10-30 20:31:33.586797+0800 KVC&amp;KVO[31665:677189] 方法名---class</span><br><span class="line">&#x2F;&#x2F;    2018-10-30 20:31:33.586934+0800 KVC&amp;KVO[31665:677189] 方法名---dealloc</span><br><span class="line">&#x2F;&#x2F;    2018-10-30 20:31:33.587038+0800 KVC&amp;KVO[31665:677189] 方法名---_isKVOA</span><br><span class="line">    [self printMethodNamesOfClass:object_getClass(self.person1)];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;手动触发</span><br><span class="line">    self.idx &#x3D; 0;</span><br><span class="line">    [self addObserver:self forKeyPath:@&quot;idx&quot; options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">    [self willChangeValueForKey:@&quot;idx&quot;];</span><br><span class="line">    [self didChangeValueForKey:@&quot;idx&quot;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    self.person1.age &#x3D; self.person2.age &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">&#x2F;&#x2F;    (lldb) po self.person1.isa</span><br><span class="line">&#x2F;&#x2F;    NSKVONotifying_Person</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    Fix-it applied, fixed expression was:</span><br><span class="line">&#x2F;&#x2F;    self.person1-&gt;isa</span><br><span class="line">&#x2F;&#x2F;    (lldb) po self.person2.isa</span><br><span class="line">&#x2F;&#x2F;    Person</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;    Fix-it applied, fixed expression was:</span><br><span class="line">&#x2F;&#x2F;    self.person2-&gt;isa</span><br><span class="line">&#x2F;&#x2F;上面是person1、person2分别打印出来的isa 可以看出isa指向NSKVONotifying_Person</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;age&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;dic--%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;手动触发</span><br><span class="line">    if ([keyPath isEqualToString:@&quot;idx&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;dicc --%@&quot;,change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印一个类所有的方法名</span><br><span class="line">- (void)printMethodNamesOfClass:(Class)cls &#123;</span><br><span class="line">    unsigned int cout;</span><br><span class="line">    Method *metodList &#x3D; class_copyMethodList(cls, &amp;cout);</span><br><span class="line">    for (int i &#x3D; 0; i&lt;cout; i++) &#123;</span><br><span class="line">        Method method &#x3D; metodList[i];</span><br><span class="line">        NSString *methodName &#x3D; NSStringFromSelector(method_getName(method));</span><br><span class="line">        NSLog(@&quot;方法名---%@&quot;,methodName);</span><br><span class="line">    &#125;</span><br><span class="line">    free(metodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的结果为：</p>
<p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/KVC%26KVO%EF%BC%88%E5%9B%9B%EF%BC%89.png" alt="Aaron Swartz"></p>
<p>在添加监听之前，我们会发现<code>person1</code>和<code>person2</code>的<code>setAge:</code>方法的地址一样（都为<code>0x10448fca0</code>），监听之后<code>person1</code>的<code>setAge:</code>方法的地址变成了<code>0x1047ec552</code>，并且用<code>object_getClassName</code>获取的它们的类，发现<code>person1</code>属于<code>NSKVONotifying_Person</code>对象,通过方法<code>printMethodNamesOfClass</code>打印该类的所有方法会发现：</p>
<p><img src="https://github.com/jaylanlu/Blog/raw/master/blogImage/KVC%26KVO%EF%BC%88%E4%BA%94%EF%BC%89.png" alt="Aaron Swartz"></p>
<p>该类有4个方法，分别是<code>setAge:，class， dealloc , _isKVOA</code><br>其实我们还可以用<code>p [_person1-&gt;isa superclass]</code>输出<code>NSKVONotifying_Person</code>类的父类，得到<code>(Class) $3 = Person</code><br>所以可以得到如下结论：</p>
<p>在用函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addObserver:forKeyPath:options:context:</span><br><span class="line">冒号后面的参数依次为：</span><br><span class="line">观察者，负责处理监听事件的对象</span><br><span class="line">观察的属性</span><br><span class="line">观察的选项</span><br><span class="line">上下文</span><br></pre></td></tr></table></figure>
<p>添加监听后runtime生成了一个类<code>NSKVONotifying_Person</code>，该类是Person的子类，并且该类重写了Person类的setAge:方法，并让person1对象的isa指向这个类，而这个类的class属性指向了原来的类Person当改变对象的age属性时，就会调用这个重写的<code>setAge:</code>方法，从而达到发送消息的目的。当我们继续运行的时候，会发现函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context</span><br><span class="line"></span><br><span class="line">发现也有4个参数分别是：</span><br><span class="line">观察的属性</span><br><span class="line">观察的对象</span><br><span class="line">属性变化字典</span><br><span class="line">上下文</span><br></pre></td></tr></table></figure>
<p>运行了，并且调用它的代码是<code>[self didChangeValueForKey:@&quot;idx&quot;]</code>，当注释掉函数<code>[self willChangeValueForKey:@&quot;idx&quot;]</code>再次运行后，会发现不会调用上面的函数，也就是说只有成对的出现才会调用。（这也就是手动调用KVO的方法，也就是注册监听后用这两个方法可以手动调用，并且[self didChangeValueForKey:@”idx”]方法能控制回调的时机）</p>
<p>但是如果，让函数<code>automaticallyNotifiesObserversForKey:</code>返回NO，那么就不会出现新的<code>NSKVONotifying_Person</code>，一切都不会发生</p>
<p>那么问题来了，能给成员变量添加KVO模式吗，答案是坑定的，因为KVO是基于KVC实现的，keyPath可是是成员变量字段，需要我们写改成员变量的setter方法，并且在setter方法里面添加两个函数<code>[self willChangeValueForKey:]</code>和<code>[self didChangeValueForKey:]</code>，在改变该成员变量的值的时候就会调用<code>observeValueForKeyPath:ofObject:change:context</code>方法.</p>
<p>当移除kvo模式时，会发现self.person1的isa指向了Person类</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2018/11/29/CPU%E5%92%8CGPU%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/29/CPU%E5%92%8CGPU%E5%90%8C%E6%AD%A5/" itemprop="url">CPU和GPU同步</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T16:36:55+08:00">
                2018-11-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>官网<a href="https://developer.apple.com/documentation/metal/advanced_command_setup/cpu_and_gpu_synchronization?language=objc" target="_blank" rel="noopener">链接</a></p>
<p>CPU/GPU并行性和共享资源访问<br>CPU和GPU是独立的异步处理器。在一个Metal app 或者游戏里面，CPU对命令进行编码,GPU执行命令。在每个frame中重复这个动作，当CPU和GPU都完成了自己的工作后一个整个的frame的工作也完成了。CPU和GPU能够并行工作并且不用等待彼此完成完成工作。例如，CPU在给frame 2编码的时候，GPU可以执行frame 1的命令。</p>
<p>这种CPU/GPU并行性对于您的Metal app或游戏具有很大的优势，有效地使您可以同时在两个处理器上运行。但是，这些处理器仍然可以协同工作，并且通常可以访问相同的共享资源，例如顶点缓冲区或片段纹理。否则，CPU和GPU可能同时访问共享资源，从而导致竞争条件和数据毁坏。</p>
<p>绝大多数Metal apps和游戏，都是通过更新frame的的顶点数据来渲染动画内容的.设想一下下面的步骤：<br>1.渲染循环启动一个新的frame.<br>2.CPU将新的顶点数据写入顶点缓冲区<br>3.CPU对渲染命令编码并提交命令到缓冲区<br>4.GPU开始执行提交的命令<br>5.GPU从顶点缓冲区读取顶点数据<br>6.GPU将像素渲染成可绘制的<br>7.渲染循环完成frame<br>在上述步骤中，CPU和GPU都共用一个顶点缓冲区。如果处理器在开始自己的工作之前等待彼此完成工作，则共享顶点缓冲区没有访问冲突。这种模式避免了访问冲突，但是浪费了宝贵的处理时间（当一个处理器工作，另一个处理器空闲时）。</p>
<img src="/2018/11/29/CPU%E5%92%8CGPU%E5%90%8C%E6%AD%A5/CPU&GPU%EF%BC%88%E4%B8%80%EF%BC%89.png" class="" title="模型图">
<p>Metal 旨在最大化CPU和GPU的并行性，因此这些处理器应该同时工作并且保持忙碌。理想情况下CPU在为frame 2写顶点数据时，GPU在读取frame 1的顶点缓冲数据。但是，共享单个顶点缓冲区意味着CPU可以在GPU读取之前覆盖前一个frame 的顶点数据，从而导致渲染出难看的成品。</p>
<img src="/2018/11/29/CPU%E5%92%8CGPU%E5%90%8C%E6%AD%A5/CPU&GPU%EF%BC%88%E4%BA%8C%EF%BC%89.png" class="" title="模型图">
<p>为了减少处理器空闲时间并且避免访问冲突，顶点数据可以共享对个缓冲区而不是一个缓冲区。例如：CPU和GPU能共享frame 1的顶点缓冲区1，frame 2的顶点缓冲区2，frame 3的顶点缓冲区3，等等。在这种模式下<br>共享顶点数据和每个frame保持一致，并且处理器同时访问不同的顶点缓冲区。</p>
<img src="/2018/11/29/CPU%E5%92%8CGPU%E5%90%8C%E6%AD%A5/CPU&GPU%EF%BC%88%E4%B8%89%EF%BC%89.png" class="" title="模型图">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="Jaylan lu" />
            
              <p class="site-author-name" itemprop="name">Jaylan lu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jaylan lu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
