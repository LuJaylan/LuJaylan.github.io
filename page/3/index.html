<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="卤蛋的博客">
<meta property="og:url" content="https://lujaylan.github.io/page/3/index.html">
<meta property="og:site_name" content="卤蛋的博客">
<meta property="article:author" content="Jaylan lu">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lujaylan.github.io/page/3/"/>





  <title>卤蛋的博客</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">卤蛋的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">勤学如春起之苗，不见其增，日有所长；辍学如磨刀之石，不见其损，日有所亏</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            日程表
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2018/11/13/%E5%B1%9E%E6%80%A7%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/13/%E5%B1%9E%E6%80%A7%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97/" itemprop="url">属性和关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-13T20:38:31+08:00">
                2018-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这段时间没有继续更新SDWebImage相关的博客了，也没有继续看了，不是因为放弃了，也放弃不了，毕竟还有许多地方值得自己仔细研读的。而是因为敲了些代码，验证了一些相关的知识点，不真正验证（光看别人的博客），永远不知道真正知识点应该是怎样的，或者说过目就忘，很难加深印象从而有自己的理解。被别人再次问道的时候很容易犹疑，或者很容易被问倒了，所以还是自己敲一下。最近感觉自己又快忘了，所以为了记忆也为了梳理一遍，就重新运行下代码，写博客记录下，著名的心里学家<a href="https://en.wikipedia.org/wiki/Hermann_Ebbinghaus" target="_blank" rel="noopener">赫尔曼·艾宾浩斯</a>提出了以他的名字命名的遗忘曲线告诉我们在短暂的记忆快要遗忘掉时加深记忆可以使得短暂的记忆变成长时间的记忆，所以可见及时复习是多么的重要。<br>###@synthesize&amp;@dynamic<br>其实有好多博客介绍过了，甚至<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/DeclaredProperty.html" target="_blank" rel="noopener">官网</a>都有相关介绍。先翻译下吧：<br>声明的属性提供了一种语法简写，用于声明类的访问器方法，并可以选择实现它们。你可以在方法声明列表中的任何位置声明属性，该列表位于类的interface中，或在protocol和category的声明中。你使用下面的语法：<br><code>@property (&lt;#attributes#&gt;) &lt;#type#&gt; &lt;#name#&gt;;</code><br>你使用关键字<code>@property</code>声明属性，你可以选择提供一组带括号的属性，这些属性定义存储语言和属性的其他行为。（有关这些属性的貌似可以参阅最终描述属性列表的文档）<br>每一个属性声明都是以类型规范和名称来结尾的。如：<br><code>@property(copy) NSString *title;</code><br>这语法等价于声明以下访问器方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)title;</span><br><span class="line">- (void)setTitle:(NSString *)newTitle;</span><br></pre></td></tr></table></figure>
<p>除了声明访问器方法，你可以指示编译器去合成它们的实现（或者通知编译器你的类将会在运行时合成它们）<br>你可以在类的实现块中使用<code>@synthesize</code>语句来告诉编译器创建与您在属性声明中提供的规范相匹配的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface MyClass : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSString *title;</span><br><span class="line">&#125;</span><br><span class="line">@property(copy) NSString *title;</span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">@implementation MyClass</span><br><span class="line">@synthesize title;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>如果找不到@property声明指定的访问器方法的实现，则使用@dynamic语句告诉编译器禁止警告。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@implementation MyClass</span><br><span class="line">@dynamic title;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>当然进一步可以看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html" target="_blank" rel="noopener">这儿</a>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">By default, these accessor methods are synthesized automatically for you by </span><br><span class="line">the compiler, so you don’t need to do anything other than declare the property using @property in the class interface.</span><br><span class="line">The synthesized methods follow specific naming conventions:</span><br><span class="line">	1.The method used to access the value (the getter method) has the same name </span><br><span class="line">	as the property.</span><br><span class="line">	2.The getter method for a property called firstName will also be called </span><br><span class="line">	firstName.</span><br><span class="line">	3.The method used to set the value (the setter method) starts with the word “set” and then uses the capitalized property name.</span><br><span class="line">	4.The setter method for a property called firstName will be called </span><br><span class="line">	setFirstName:.</span><br></pre></td></tr></table></figure>
<p>默认情况下，编译器会自动合成访问器方法，所以在类的<code>interface</code>中用<code>@property</code>声明了属性后就不用写相关的访问器方法。<br>    1.访问器方法（<code>getter</code>方法）和属性拥有相同的方法名<br>    2.名为<code>firstName</code>的属性的<code>getter</code>方法的方法名也是<code>firstName</code><br>    3.给属性设置值得方法（<code>setter</code>方法）是以<code>“set”</code>开始然后以大写的属性名<br>    4.名为<code>firstName</code>的属性的<code>setter</code>方法的方法名是<code>setFirstName</code></p>
<p>前面介绍过，其实<code>@property</code>关键字是就完成了set方法和get方法，但是有的人可能会发现存在<code>_firstName</code>变量:<br>当你在<code>@implementation</code>里面加入<code>@dynamic firstName;</code>时，你会发现firstName不见了；且给<code>self.firtName</code>赋值时会发现缺少<code>setFirstName:</code>方法崩溃，而<code>NSString *a = self.firstName;</code>取firstName时，你会发现缺少<code>firstName</code>方法。所以<strong>@dynamic的作用为：</strong></p>
<p><strong>告诉编译器该属性的<code>getter</code>方法和<code>setter</code>需要程序员手动实现，不能自动生成，否则会在赋值或访问的时候会因为缺少相对应的函数而导致程序崩溃。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.firstName &#x3D; @&quot;&quot;;&#x2F;&#x2F;!崩溃 -[ViewController setFirstName:]: unrecognized selector sent to instance 0x7fce2a204ff0</span><br><span class="line">NSString *a &#x3D; self.firstName;&#x2F;&#x2F;!崩溃 -[ViewController firstName]: unrecognized selector sent to instance 0x7fe7d3d0ff20</span><br></pre></td></tr></table></figure>

<p>默认情况下(不添加@synthesize)<code>@synthesize var = _var</code> ，你会发现会莫名其妙多一个成员变量<code>_var</code>，并且它的内存地址和self.var相同，说明它们指向的是同一个东西。但是<code>_secondName = @&quot;&quot;;//不会调用setter方法</code>不会调用setter方法，而<code>self.secondName = @&quot;&quot;;//会调用setter方法</code>会调用setter方法，这是因为前者是直接访问成员变量，而后者是访问setter方法。同时，你会发现如果同时重写了<code>secondName</code>的getter方法和setter方法，编译器不识别成员变量<code>_secondName</code>了，这个时候需要手动添加<code>@synthesize secondName = _secondName</code>（因为这个时候编译器不会自动生成成员变量）或者自己添加成员变量。</p>
<p><code>NSLog(@&quot;%p---%p&quot;,_secondName,self.secondName);//0x0---0x0</code></p>
<p>当然，如果已经声明了一个<code>_var</code>成员变量，就不会再多一个同名的成员变量;<br>这个成员变量和自动生成的成员变量一样都是和<code>self.var</code>指向同一个内存地址</p>
<p>当你添加上<code>@synthesize firstName = myfirstName</code>或者是<code>@synthesize firstName</code>时，你会发现原来的<code>_firstName消失</code>了，并且出现了一个<code>myfirstName</code>成员变量，或者<code>firstName</code>成员变量,并且他们和原来的<code>self.firstNamed</code>一样都是指向相同的对象，这时候可以用<code>myfirstName</code>或者<code>firstName</code>访问；</p>
<p>所以可以认为<code>@synthesize</code>有以下作用：</p>
<p><strong>1, 当程序员没有手动重写属性的访问方法时（setter和getter）,@synthesize会告诉编译器自动合成</strong></p>
<p><strong>2, 生成一个成员变量(如果已经存在相关成员变量就不再生成了),并且该成员变量和self.var指向相同的内存地址，不同的是成员变量不会调用访问方法</strong></p>
<p><strong>3, 如果指定合成相关成员变量的名称</strong></p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>在上面的说明中，我们会发现，自动合成不是一定会发生的，所以手动添加<code>@synthesize</code>是必要的，那么手动添加<code>@synthesize</code>的场景有哪些呢，我们可以先看下哪些情况下系统是不会自动添加<code>@synthesize</code>:</p>
<p>1，使用了@dynamic时（这个时候不能添加<code>@synthesize</code>–<code>Property &#39;secondName&#39; is already implemented</code>,@dynamic和@synthesize不能同时处理一个属性，否则后面的就会报这个错误）；<br>2，同时重写了setter和getter方法（上面介绍过）；<br>3，重写了只读属性的getter方法（和1一样，因为编译器不会合成setter和getter方法了，也不合成成员变量，导致重写时返回成员变量不识别；<br>4，重写父类的属性时，此时需要重写访问方法，因为不识别成员变量，所以需要添加；<br>5，在@protocol中定义的属性（有博客说category中的的属性也是的，但是本人经过实验，发现在category中不允许添加<code>@synthesize</code>）；<br>6，在@category中定义的属性（但category中不允许添加<code>@synthesize</code>的–<code>@synthesize not allowed in a category&#39;s implementation</code>）<br>总之，除了1和6之不能添加外其他的情况都需要手动添加<code>@synthesize</code>，其他都是因为没有自动合成成员变量所以需要手动添加<code>@synthesize</code>，或者你想手动管理属性时就应该手动添加。<br>=======<br>在上面的说明中，我们会发现，自动合成不是一定会发生的，所以手动添加<code>@synthesize</code>是必要的，那么手动添加<code>@synthesize</code>的场景有哪些呢(<a href="https://stackoverflow.com/questions/19784454/when-should-i-use-synthesize-explicitly/19784662" target="_blank" rel="noopener">https://stackoverflow.com/questions/19784454/when-should-i-use-synthesize-explicitly/19784662</a>)<br>1，同时重写了setter和getter方法（上面介绍过）<br>2，重写了只读属性的getter方法（和1一样，因为编译器不会合成setter和getter方法了，也不合成成员变量，导致重写时返回成员变量不识别）<br>3，重写父类的属性时,此时需要重写访问方法，因为不识别成员变量，所以需要添加<br>4，在@protocol中定义的属性（有博客说category中的的属性也是的，但是本人经过实验，发现在category中不允许添加<code>@synthesize</code>）<br>总之，除了4以外，其他都是因为没有自动合成成员变量所以需要手动添加<code>@synthesize</code></p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>1a17da72b11a100c330cff1c9715e3d61a5e431f</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>从上面的说明中可以知道<code>@property</code>的本质就是<code>iVar + getter + setter</code>，也就是“实例变量（iVar）”和“存取方法（access method = getter(获取方法) + setter(设置方法)）”。属性作为Objective-C的一个特性，主要的作用就是用于封装类中相关的数据，Objective-C对象通常会把其所需要的数据保存为各种实例变量，而用“存取方法”访问这些数据，其中“获取方法”<code>getter</code>用于读取，“设置方法”<code>setter</code>用于写入。</p>
<p>其实也可以大致猜测到实例变量和存取方法时怎么添加到类中的，说白了就是“自动合成<code>autosynthesis</code>”，我们知道“实例变量”和“类变量”合称为“成员变量”，那么添加实例变量时，肯定会将该属性的描述添加成员变量列表，同时也会在属性列表中添加相关的属性描述，然后我们知道类的存储方式类似于结构体，里面的属性存取和数组类似（可以参考<a href="https://stackoverflow.com/questions/2748995/struct-memory-layout-in-c" target="_blank" rel="noopener">这儿</a>,有兴趣可以动手验证下），是连续的地址，所以有个对初始地址的偏移量的计算，接着是实现“存取方法”，<code>getter</code>和<code>setter</code>的读取和写入都是从偏移量开始的。<br>总之，每一增加一个属性值都会有以下操作：<br>1，在ivar_list（成员变量列表）中添加成员变量的描述<br>2, 在method_list (方法列表)中添加setter和getter方法的描述<br>3，在属性列表中增加一个属性的描述<br>4，计算该属性在对象中的偏移量<br>5，给出setter和getter方法对应的实现<br>###属性修饰关键字<br>属性关键字可以分为四类：原子性，读写权限，内存管理语义，方法名</p>
<p>在介绍属性修饰关键字之前不得不介绍这些关键字的排序，一般来说应该按照下面的顺序来排序：原子性，读写权限和内存管理</p>
<p>####原子性（nonatomic&amp;atomic）<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html" target="_blank" rel="noopener">官方资料</a><br>默认情况下属性都是原子性的（<code>atomic</code>）,也就是说，开发人员不指定原子性的属性一般都是原子性的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface XYZObject : NSObject</span><br><span class="line">@property NSObject *implicitAtomicObject;          &#x2F;&#x2F; atomic by default</span><br><span class="line">@property (atomic) NSObject *explicitAtomicObject; &#x2F;&#x2F; explicitly marked atomic</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这就意味着编译器合成的访问方法确保了访问属性都是通过相关的属性访问方法（读取通过<code>getter</code>方法，设置通过<code>setter</code>方法），即使多个线程同时访问属性，也是这样。<br>这是因为原子访问器方法的内部实现和同步都是私有的，因此不可能将合成访问器与您自己实现的访问器方法组合起来。例如，如果您尝试为原子读写属性提供自定义<code>setter</code>,但让编译器和成<code>getter</code>,则会得到编译警告(<code>Writable atomic property &#39;atomicS&#39; cannot pair a synthesized getter with a user defined setter</code>)。</p>
<p>你可以用<code>nonatomic</code>指定属性的非原子性    ，这样合成访问器就简单的直接设置和返回相对应的值，但是在有多个不同的线程同时访问该属性时可能会发生未知的错误，它也可以将合成的<code>setter</code>方法和自定义的<code>getter</code>方法组合起来</p>
<p>但是<code>atomic</code>就一定线程安全吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Note: Property atomicity is not synonymous with an object’s thread safety.</span><br><span class="line"></span><br><span class="line">Consider an XYZPerson object in which both a person’s first and last names are changed using atomic accessors from one thread. If another thread accesses both names at the same time, the atomic getter methods will return complete strings (without crashing), but there’s no guarantee that those values will be the right names relative to each other. If the first name is accessed before the change, but the last name is accessed after the change, you’ll end up with an inconsistent, mismatched pair of names.</span><br><span class="line"></span><br><span class="line">This example is quite simple, but the problem of thread safety becomes much more complex when considered across a network of related objects. Thread safety is covered in more detail in [Concurrency Programming Guide]().</span><br></pre></td></tr></table></figure>
<p>就像一个XYZPerson对象，在该对象中，使用来自一个线程的原子访问器更改人的姓和名。如果另一个线程同时访问这两个名称，原子getter方法将返回完整的字符串(不会崩溃)，但是不能保证这些值是相对于彼此的正确名称。如果在更改之前访问了姓，而在更改之后访问了姓，那么您将得到一对不一致的、不匹配的名称。</p>
<p>####方法名&amp;读写权限<br>其实开始本篇博客的写作的决定是来自<code>SDWebImage SDK</code>的阅读的，它有一个类的一个属性定义是<code>@property (nonatomic, assign, getter=isFinished) BOOL finished;</code>这样的，如果想重写该属性的<code>getter</code>方法，你会发现只有<code>isFinished</code>的提示，而没有<code>finished</code>的提示，但是运行时，无论是<code>self.finished</code>还是<code>self.isFinished</code>都会调用<code>isFinished</code>getter方法.通过打印会发现<code>self.finished</code>、<code>self.isFinished</code>和<code>_finished</code>指向的是同一个内存地址。<br>所以<code>getter=isFinished</code>作用为：<br>1，更改了<code>getter</code>方法的方法名(<code>setter = method</code>也可以更改方法名)<br>2，给该属性添加了一个新的访问途径，并且该途径和<code>_finished</code>一模一样</p>
<p>在此说明一下readOnly的作用(如果给上面的属性添加readonly，默认是readwrite):<br>限制了函数外更改<code>finished</code>属性，现在的属性因为没有“设置方法”所以不能用点语法更改，所以只能通过成员变量（下划线）的方式更改，所以只能在函数内更改</p>
<p>####内存管理语义<br>先上代码：</p>

<p>其中self.strongStr、self.weakStr、self.assignStr、self.cp都分别是用相对应的关键字（stong、weak、assign、copy）修饰的属性，后面注释部分是打印输出。</p>
<p><code>self.strongStr = strM;</code>这句代码之后strM的引用计数加一，<code>self.strongStr = nil;</code>这句代码执行之后引用计数减一<br>可知strong关键字（强引用）会影响引用计数的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.weakStr &#x3D; strM;</span><br><span class="line">  self.assignStr &#x3D; strM;</span><br><span class="line">  self.cpStr &#x3D; strM;</span><br></pre></td></tr></table></figure>
<p>执行之后引用计数没变，可知在这段代码中<code>weak、assign、copy</code>没有影响引用计数<br><code>NSLog(@&quot;%p-%p-%p-%p-%p&quot;,strM,self.weakStr,self.assignStr,self.strongStr,self.cpStr);//0x600000969e90-0x600000969e90-0x600000969e90-0x600000969e90-0xcc8bd2833e56ff1c</code><br>打印它们的指向的地址，会发现只有self.cpStr的地址和其他的不同，所以copy实现了<a href="">深拷贝</a>,开辟了新的内存，而<code>weak assign</code>不影响引用计数</p>
<p>那么<code>weak</code>和<code>assign</code>有什么区别呢？<br>用<code>-fno-objc-arc</code>关闭arc后，<code>[strM release]</code>执行后，释放掉该对象然后用命令分别打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p self.weakStr</span><br><span class="line">(NSString *) $0 &#x3D; nil</span><br><span class="line">(lldb) p self.assignStr</span><br><span class="line">(NSString *) $2 &#x3D; 0x000060000066b150</span><br></pre></td></tr></table></figure>
<p>会发现，对象释放掉后，weakStr的指针置空了，而assignStr的指针没有置空<br>也就是说：weak 和assign的不同就是,weak修饰的对象会在对象释放掉后置空指针，而assign不会置空指针。（当然还有weak只用于修饰对象类型，而assign可用于修饰对象类型和基本数据类型）</p>
<p>总结如下：<a href="https://stackoverflow.com/questions/8927727/objective-c-arc-strong-vs-retain-and-weak-vs-assign/15541801#15541801" target="_blank" rel="noopener">参考</a></p>
<p><strong><code>strong(=retain)</code>//Objective-C对象默认修饰关键字</strong></p>
<p>定义了一种拥有关系，只有在你想持有该对象的时候才会用。通常对<code>UIViewControllers</code>用，在arc环境下，不用担心对象的引用计数，arc会自动释放</p>
<p><strong><code>weak</code></strong></p>
<p>定义了一种非拥有的关系，只要有强引用指向改对象，弱引用就会一直保留该对象，这点和assign一样，并且不会持有和释放该对象。<br>通常用于IBOutlets，因为这些对象只需要在父对象UIViewController存在的时候存在就好。<br>弱引用是不保护引用对象不被垃圾收集器收集的引用。对象在摧毁时，weak指针会自动置空，而assign指针不会，这是它们唯一的区别。只有在避免循环的时候才用weak。</p>
<p><strong><code>assign</code>//基本数据类型默认修饰关键字</strong></p>
<p>用assign修饰C基本数据类，用weak修饰弱引用的Objective-C对象，当对象释放掉后，由于assign指针没有置空，所以会造成野指针，而Objective-C对象是在堆上，对象释放掉后，如果采用的是assign指针，就会造成野指针，当再次分配该内存时就会崩溃，而栈是由系统自己处理的</p>
<p><strong><code>copy</code></strong></p>
<p>用于实现浅拷贝，将不可变属性设置成copy可以确保：<br>当可变对象传递给该属性时，属性都是不可变对象。（因为可变类型可以传递个相对应的不可变类型）。如果传入一个不可变对象，改属性可以保留它（浅拷贝），如果传入一个可变对象，它将会开辟一个新的内存复制它，实现深拷贝（当然集合类型的可变类型实现的也是浅拷贝）。</p>
<p>当将可变属性设置成copy时，这是就相当于strong，如果不可变类型传入，调用可变类型的特有方法时会崩溃</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_ss1 &#x3D; [NSMutableString stringWithFormat:@&quot;&quot;];&#x2F;&#x2F;(lldb) p _ss1 (__NSCFString *) $0 &#x3D; 0x0000600002a7de60</span><br><span class="line">NSString *str &#x3D; [NSString stringWithFormat:@&quot;sfds&quot;];&#x2F;&#x2F;(lldb) p _ss1  (__NSCFString *) $0 &#x3D; 0x0000600002a7de60</span><br><span class="line">_ss1 &#x3D; str;&#x2F;&#x2F;p _ss1  (NSTaggedPointerString *) $2 &#x3D; 0xb92d0fbc87c5b067 @&quot;sfds&quot;</span><br><span class="line">[_ss1 appendFormat:@&quot;ds&quot;];&#x2F;&#x2F;[NSTaggedPointerString appendFormat:]: unrecognized selector sent to instance</span><br></pre></td></tr></table></figure>
<p>每句代码后面的注释是执行这句代码后断点打印出来的，最后一句是崩溃输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">weak不能用于修饰非Objective-C对象</span><br><span class="line">assign可以用于修饰非基本数据类型（Objective-C对象）</span><br><span class="line">Objective-C的默认修饰关键字为strong </span><br><span class="line">基本数据类型的默认修饰关键字为assign</span><br></pre></td></tr></table></figure>

<p>####weak关键字的实现<br>这个好多博客都有介绍，在此也不刨runtime源码了（第一次看的话会头大，有兴趣的可以多看看）<br>言简意赅地总结下：</p>
<p>#####weak的作用<br>weak是弱引用，它不会影响引用对象的引用计数，将它所修饰的指针（弱指针）指向一个对象时，不会导致该对象的引用计数加一，当该对象释放时这个弱指针会自动设置成nil，避免了野指针访问内存引起崩溃（这也是不用assign修饰Objective-C对象的原因），主要用于解决循环引用而导致的<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/FindingLeaks.html" target="_blank" rel="noopener">内存泄漏</a><br>#####weak的原理<br>weak表其实是一个以所指对象的地址为key,weak指针地址所组成的数组为value的hash表，有objc_initWeak,objc_storeWeak,objc_destoryWeak。</p>
<p>#####原理实现步骤<br>1，初始化。runtime会调用objc_initWeak函数，objc_initWeak函数会初始化一个新的weak指针指向对象的地址。<br>2，添加引用。objec_initWeak函数会调用objc_storeWeak函数来更新指针指向，创建对应的弱引用表。<br>3，消除引用。对象释放时，调用clearDeallocationg函数，首先获取weak指针地址的数组，然后遍历数组把其中的数据置为nil，接着将这个记录从weak表中删除，从引用计数表中删除废弃对象的记录</p>
<p>如：Objective-C对象obj，现在有两个弱指针weakPointer0、weakPointer1指向它，那么这个weak表中就存在一个以obj内存地址为key的一个元素，该元素的value是以两个弱指针的地址为元素的数组，这也解释了为什么是数组而不是数（因为可能存在多个弱指针）<br>这部分参考的<a href="http://www.cocoachina.com/ios/20171213/21520.html" target="_blank" rel="noopener">这儿</a></p>
<p>###拷贝与可变、不可变之间的关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在运行到第一行和第二行的时候分别在控制台打印地址（p str和p &amp;str）会发现p str打印的地址变了，而p &amp;str打印的地址没变，从而可以知道p str打印的是指针所指对象的z地址，p &amp;str打印的是指针变了的地址(指针地址)</span><br><span class="line">    NSString *str &#x3D; @&quot;hello&quot;;&#x2F;&#x2F;1</span><br><span class="line">    str &#x3D; @&quot;world&quot;;&#x2F;&#x2F;2</span><br><span class="line">    </span><br><span class="line">    self.ss0 &#x3D; @&quot;ss0&quot;;</span><br><span class="line">    self.ss1 &#x3D; [[NSMutableString alloc] initWithString:@&quot;ss1&quot;];</span><br><span class="line">    &#x2F;&#x2F;浅拷贝，地址一样</span><br><span class="line">    id ss0_copy &#x3D; [self.ss0 copy];</span><br><span class="line">    NSLog(@&quot;ss0---%p--%p&quot;,self.ss0,ss0_copy);&#x2F;&#x2F;打印出来的效果和p self.ss0是相同的</span><br><span class="line">    __unused id ss0_sub &#x3D; [ss0_copy substringFromIndex:1];</span><br><span class="line">&#x2F;&#x2F;    [ss0_copy appendString:@&quot;_m&quot;];&#x2F;&#x2F;崩溃，生成的副本是不可变的</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;深拷贝，地址不同</span><br><span class="line">    id ss1_copy &#x3D; [self.ss1 copy];</span><br><span class="line">    NSLog(@&quot;ss1---%p--%p&quot;,self.ss1,ss1_copy);</span><br><span class="line">&#x2F;&#x2F;        [ss1_copy appendString:@&quot;_m&quot;];&#x2F;&#x2F;崩溃，生成的副本是不可变的</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;深拷贝，ss0_mutableCopy 和self.ss0指向的对象不一样</span><br><span class="line">    id ss0_mutableCopy &#x3D; [self.ss0 mutableCopy];</span><br><span class="line">    id ss1_mutableCopy &#x3D; [self.ss1 mutableCopy];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;ss0---%p--%p&quot;,self.ss0,ss0_mutableCopy);</span><br><span class="line">    NSLog(@&quot;ss1---%p--%p&quot;,self.ss1,ss1_mutableCopy);</span><br><span class="line">    &#x2F;&#x2F;下面两个都正常运行，表明生成的副本都是可变的</span><br><span class="line">    [ss0_mutableCopy appendString:@&quot;_m&quot;];</span><br><span class="line">    [ss1_mutableCopy appendString:@&quot;_m&quot;];</span><br><span class="line">    </span><br><span class="line"> &#x2F;&#x2F;小结：对于字符串，只有不可变字符串的copy才是浅拷贝，其他都是深拷贝；copy生成的都是不可变字符串，mutableCopy生成的都是可变字符串</span><br></pre></td></tr></table></figure>
<p>所以，对于字符串来说，只有不可变字符串的copy才是浅拷贝，其他的都是深拷贝；copy生成的都是不可变字符串，mutableCopy生成的都是可变字符串，和被拷贝的字符串是否可变无关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;打印出来的地址相同，浅拷贝</span><br><span class="line">    self.set0 &#x3D; [[NSSet alloc] initWithObjects:@1,@2,@3, nil];</span><br><span class="line">    id set0_copy &#x3D; [self.set0 copy];</span><br><span class="line">    &#x2F;&#x2F;    [set0_copy addObject:@4];&#x2F;&#x2F;崩溃，副本是不可变的</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;打印出来的地址相同，浅拷贝</span><br><span class="line">    self.set1 &#x3D; [[NSMutableSet alloc] initWithObjects:@1,@2,@3, nil];</span><br><span class="line">    id set1_copy &#x3D; [self.set1 copy];</span><br><span class="line">    &#x2F;&#x2F;    [set1_copy addObject:@5];&#x2F;&#x2F;崩溃，副本是不可变的</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;打印出来的地址不同，但里面的每个元素的地址相同，没有做内容拷贝</span><br><span class="line">    id set0_mutableCopy &#x3D; [self.set0 mutableCopy];</span><br><span class="line">    [set0_mutableCopy addObject:@6];&#x2F;&#x2F;正常运行，副本是可变的</span><br><span class="line">    id set1_mutableCopy &#x3D; [self.set1 mutableCopy];</span><br><span class="line">    [set1_mutableCopy addObject:@7];&#x2F;&#x2F;正常运行，副本是可变的</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;小结：严格的来说集合的所有拷贝都是浅拷贝，只有不可变数组的copy没有进行指针拷贝，其他的都只是进行了指针拷贝；copy生成的副本都是不可变的，mutableCopy生成的副本都是可变的，这个和字符串相同</span><br></pre></td></tr></table></figure>
<p>在此没有一一列举字典和集合的测试代码，其实结果和数组是一样的。就像代码中的小结一样：</p>
<p>严格的来说集合的所有拷贝都是浅拷贝，只有不可变数组的copy没有进行指针拷贝，其他的都只是进行了指针拷贝；copy生成的副本都是不可变的，mutableCopy生成的副本都是可变的，这个和字符串相同</p>
<p>本篇博客好多都是参考<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#8-runtime-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-weak-%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">这里</a>，干货满满，但是还是验证下为好，毕竟纸上得来终觉浅呀</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2018/10/10/SDWebImage-%E4%B8%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/10/SDWebImage-%E4%B8%89/" itemprop="url">SDWebImage(三)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-10T19:55:27+08:00">
                2018-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="SDWebImageDownloaderOperationInterface"><a href="#SDWebImageDownloaderOperationInterface" class="headerlink" title="SDWebImageDownloaderOperationInterface"></a>SDWebImageDownloaderOperationInterface</h3><p>作用：描述一个下载器操作。若用一个自定义的下载器操作，该下载器需要继承<code>NSOperation</code>并且遵守该协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadStartNotification;</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadReceiveResponseNotification;</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadStopNotification;</span><br><span class="line">FOUNDATION_EXPORT NSString * _Nonnull const SDWebImageDownloadFinishNotification;</span><br></pre></td></tr></table></figure>
<p>表名这几个<a href="">指针常量</a>是从外部查找的，其中<code>FOUNDATION_EXPORT</code>的相关代码位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#if defined(__cplusplus)</span><br><span class="line">#define FOUNDATION_EXTERN extern&quot;C&quot;</span><br><span class="line">#else</span><br><span class="line">#define FOUNDATION_EXTERN extern</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define FOUNDATION_EXPORT  FOUNDATION_EXTERN</span><br></pre></td></tr></table></figure>
<p>兼容了<code>extern&quot;C&quot;</code>和<code>extern</code>,感兴趣的可以看看<a href=""><code>extern</code></a>。当然这一块不属于该协议中的内容。<br>该协议声明了七个方法，没有给出关键字<code>@optional</code>默认为必须实现。<br>第一个方法是根据三个参数生成一个下载操作的实例；第二个方法是给下载操作加入下载过程中和下载结束后需要执行的block；第三个函数返回下载的图片是否需要压缩；第四个设置压缩参数；第五个返回身份认证；第六个是设置身份认证；第七个是取消当前操作。</p>
<h3 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloaderOperation : NSOperation &lt;SDWebImageDownloaderOperationInterface, SDWebImageOperation, NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;</span><br></pre></td></tr></table></figure>
<p>该类是自定义的下载操作，继承<code>NSOperation</code>、实现了<code>SDWebImageDownloaderOperationInterface</code>、<code>SDWebImageOperation</code>、<code>NSURLSessionTaskDelegate、</code>NSURLSessionDataDelegate `</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * The request used by the operation&#39;s task.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) NSURLRequest *request;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The operation&#39;s task</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) NSURLSessionTask *dataTask;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic) BOOL shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  Was used to determine whether the URL connection should consult the credential storage for authenticating the connection.</span><br><span class="line"> *  @deprecated Not used for a couple of versions</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, assign) BOOL shouldUseCredentialStorage __deprecated_msg(&quot;Property deprecated. Does nothing. Kept only for backwards compatibility&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The credential used for authentication challenges in &#96;-URLSession:task:didReceiveChallenge:completionHandler:&#96;.</span><br><span class="line"> *</span><br><span class="line"> * This will be overridden by any shared credentials that exist for the username or password of the request URL, if present.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (nonatomic, strong, nullable) NSURLCredential *credential;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The SDWebImageDownloaderOptions for the receiver.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (assign, nonatomic, readonly) SDWebImageDownloaderOptions options;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The expected size of data.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (assign, nonatomic) NSInteger expectedSize;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * The response returned by the operation&#39;s task.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (strong, nonatomic, nullable) NSURLResponse *response;</span><br></pre></td></tr></table></figure>
<p>以上代码是声明的属性：<br><code>request</code>: 操作任务的url请求<br><code>dataTask</code>: 操作的任务<br><code>shouldDecompressImages</code>: 图像是否压缩<br><code>shouldUseCredentialStorage</code>: 用于确定url连接是否应该参考存储的身份认证来验证连接<br><code>credential</code>: 用于在<code>-URLSession:task:didReceiveChallenge:completionHandler:</code>验证的凭据，如果存在请求URL的用户名或密码，则会覆盖此任何共享凭据。<br><code>options</code>: 下载操作的配置选项,<code>SDWebImageDownloaderOptions</code>属性<br><code>expectedSize</code>: 期望的数据大小<br><code>response</code>: 下载操作任务请求的返回对象<br>下面是对外的API方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> * The response returned by the operation&#39;s task.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@property (strong, nonatomic, nullable) NSURLResponse *response;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  Initializes a &#96;SDWebImageDownloaderOperation&#96; object</span><br><span class="line"> *</span><br><span class="line"> *  @see SDWebImageDownloaderOperation</span><br><span class="line"> *</span><br><span class="line"> *  @param request        the URL request</span><br><span class="line"> *  @param session        the URL session in which this operation will run</span><br><span class="line"> *  @param options        downloader options</span><br><span class="line"> *</span><br><span class="line"> *  @return the initialized instance</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  Adds handlers for progress and completion. Returns a tokent that can be passed to -cancel: to cancel this set of</span><br><span class="line"> *  callbacks.</span><br><span class="line"> *</span><br><span class="line"> *  @param progressBlock  the block executed when a new chunk of data arrives.</span><br><span class="line"> *                        @note the progress block is executed on a background queue</span><br><span class="line"> *  @param completedBlock the block executed when the download is done.</span><br><span class="line"> *                        @note the completed block is executed on the main queue for success. If errors are found, there is a chance the block will be executed on a background queue</span><br><span class="line"> *</span><br><span class="line"> *  @return the token to use to cancel this set of handlers</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (nullable id)addHandlersForProgress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  Cancels a set of callbacks. Once all callbacks are canceled, the operation is cancelled.</span><br><span class="line"> *</span><br><span class="line"> *  @param token the token representing a set of callbacks to cancel</span><br><span class="line"> *</span><br><span class="line"> *  @return YES if the operation was stopped because this was the last token to be canceled. NO otherwise.</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (BOOL)cancel:(nullable id)token;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)initWithRequest:(nullable NSURLRequest *)request</span><br><span class="line">                              inSession:(nullable NSURLSession *)session</span><br><span class="line">                                options:(SDWebImageDownloaderOptions)options NS_DESIGNATED_INITIALIZER;</span><br></pre></td></tr></table></figure>
<p>指定的初始化方法，返回一个实例。后面两个前面介绍过，就不重复了。</p>
<h4 id="m文件中"><a href="#m文件中" class="headerlink" title=".m文件中"></a>.m文件中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#if (__IPHONE_OS_VERSION_MIN_REQUIRED &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_9_0)</span><br></pre></td></tr></table></figure>
<p><code>__IPHONE_OS_VERSION_MIN_REQUIRED</code>: 指的Deployment target,Xcode配置最低的版本<br>后面定义了NSURLSession任务的三个优先级，都是常量。不禁让人想起UI<a href="">约束</a>的<a href="">优先级</a>,在更新优先级是不能更改优先级为1000的优先级，或者不能将优先级改为1000，因为不能将可遵守的约束改成必须遵守的约束（也不能将必须遵守的约束改成可遵守的约束），而优先级为1000的约束表明该约束是必须需要遵守的，当然这是题外话。<br>上面说到的指针常量（用于通知）是在这儿定义的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *const SDWebImageDownloadStartNotification &#x3D; @&quot;SDWebImageDownloadStartNotification&quot;;</span><br><span class="line">NSString *const SDWebImageDownloadReceiveResponseNotification &#x3D; @&quot;SDWebImageDownloadReceiveResponseNotification&quot;;</span><br><span class="line">NSString *const SDWebImageDownloadStopNotification &#x3D; @&quot;SDWebImageDownloadStopNotification&quot;;</span><br><span class="line">NSString *const SDWebImageDownloadFinishNotification &#x3D; @&quot;SDWebImageDownloadFinishNotification&quot;;</span><br></pre></td></tr></table></figure>
<p>刚好，下面也定义了指针常量（姑且称为状态）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static NSString *const kProgressCallbackKey &#x3D; @&quot;progress&quot;;</span><br><span class="line">static NSString *const kCompletedCallbackKey &#x3D; @&quot;completed&quot;;</span><br></pre></td></tr></table></figure>
<p>与上面定义的通知指针常量和这儿定义状态常量只少了<a href=""><code>static</code></a>，还有<a href=""><code>const</code></a>关键字也可以关注下。</p>
<p><code>typedef NSMutableDictionary&lt;NSString *, id&gt; SDCallbacksDictionary;</code>: 定义了一个类型，用<a href=""><code>typedef</code></a>指明用到的<code>SDCallbacksDictionary</code> 都是表示类型<code>NSMutableDictionary&lt;NSString *, id&gt;</code>,该类型是一个可变字典，这个字典的key为string类型，value为id<a href="">动态类型</a>。可能有的人会说字典的key不都是string类型吗，其实这是一个很容易出现的错误（习惯到知道）。文档给出的原文是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In general, a key can be any object (provided that it conforms to the NSCopying protocol—see below), but note that when using key-value coding the key must be a string</span><br></pre></td></tr></table></figure>
<p>也就是说，除了用<a href="">键值编码</a>必须要求key为string类型外，通常来说key可以是任意对象。</p>
<p>.m中私有属性有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloaderOperation ()</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableArray&lt;SDCallbacksDictionary *&gt; *callbackBlocks;</span><br><span class="line"></span><br><span class="line">@property (assign, nonatomic, getter &#x3D; isExecuting) BOOL executing;</span><br><span class="line">@property (assign, nonatomic, getter &#x3D; isFinished) BOOL finished;</span><br><span class="line">@property (strong, nonatomic, nullable) NSMutableData *imageData;</span><br><span class="line">@property (copy, nonatomic, nullable) NSData *cachedData; &#x2F;&#x2F; for &#96;SDWebImageDownloaderIgnoreCachedResponse&#96;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; This is weak because it is injected by whoever manages this session. If this gets nil-ed out, we won&#39;t be able to run</span><br><span class="line">&#x2F;&#x2F; the task associated with this operation</span><br><span class="line">@property (weak, nonatomic, nullable) NSURLSession *unownedSession;</span><br><span class="line">&#x2F;&#x2F; This is set if we&#39;re using not using an injected NSURLSession. We&#39;re responsible of invalidating this one</span><br><span class="line">@property (strong, nonatomic, nullable) NSURLSession *ownedSession;</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic, readwrite, nullable) NSURLSessionTask *dataTask;</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t callbacksLock; &#x2F;&#x2F; a lock to keep the access to &#96;callbackBlocks&#96; thread-safe</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_queue_t coderQueue; &#x2F;&#x2F; the queue to do image decoding</span><br><span class="line">#if SD_UIKIT</span><br><span class="line">@property (assign, nonatomic) UIBackgroundTaskIdentifier backgroundTaskId;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic, nullable) id&lt;SDWebImageProgressiveCoder&gt; progressiveCoder;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>意译的理解为：<br><code>callbackBlocks</code>: 数组，数组里面元素遵守<code>SDCallbacksDictionary</code>,也可以认为数组里面是<code>SDCallbacksDictionary</code>对象；<br><code>executing</code>: 是否在执行，get函数为<code>isExecuting</code>，所以后面都是用self.isExecuting来访问该属性的;<br><code>finished</code>: 执行是否接受，get函数为<code>isFinished</code>;<br><code>imageData</code>: 图像数据，<code>NSMutableData</code>类型,可为空;<br><code>cachedData</code>: 缓存数据;<br><code>unownedSession</code>: 无主的<code>NSURLSession</code>,用weak关键字修饰是因为它是由管理此会话的对象注入的，如果被取消，我们将无法运行与此操作相关的任务,可能是由该操作的持有者引入的。<br><code>ownedSession</code>: 若不用<code>unownedSession</code>，可以用这个；<br><code>dataTask</code>: 操作的任务；<br><code>callbacksLock</code>: 用信号量声明的锁，为了使得<code>callbackBlocks</code>的访问线程安全；<br><code>coderQueue</code>: 图像解码队列；<br><code>backgroundTaskId</code>: 后台任务id<br><code>progressiveCoder</code>: 图像渐进编码；</p>
<h5 id="implementation"><a href="#implementation" class="headerlink" title="@implementation"></a>@implementation</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@synthesize executing &#x3D; _executing;</span><br><span class="line">@synthesize finished &#x3D; _finished;</span><br></pre></td></tr></table></figure>
<p>这儿用到了关键字<a href=""><code>synthesize</code></a>，其实这样写后self.executing和self.isExecuting是一样的。其中我们需要了解<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/DeclaredProperty.html"><code>property</code></a>相关的作用。</p>
<p>下面就是方法的具体实现了：<br>开始是一个<a href=""><code>convenience init</code></a>(便宜构造方法)，调用<a href=""><code>designated init</code></a>(指定构造方法，也就是第二个方法）。在指定的构造方法中，是建议所有的属性都被初始化（当然可为空的除外），特别是<code>readonly</code>关键字修饰的属性，若不在构造方法中被初始化，那么其他地方也初始化不了(当然下划线访问(<a href="">KVC</a>)的除外，因为它不调用setter方法)，有兴趣的可以戳<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html">这里</a>。另外，<code>ViewController</code>进入的方式不同，所调用的初始化方法也不一样，可以戳<a href="">这里</a>哦。</p>
<p>第三个方法是给下载器操作添加block的，以字典的形式将<code>SDWebImageDownloaderProgressBlock</code>和<code>SDWebImageDownloaderCompletedBlock</code>类型的block 加入到属性<code>callbackBlocks</code>中。</p>
<p>第四个方法是根据key回调相应的block，<code>[callbacks removeObjectIdenticalTo:[NSNull null]];</code>:是移除<code>[NSNull null]</code></p>
<p>第五个方法时根据token取消相应的操作，<code>[self.callbackBlocks removeObjectIdenticalTo:token];</code>有点看不明白，<code>callbackBlocks</code>是字典数组怎么移除token,不过搜索一下相对应的token会发现token是函数<code>addHandlersForProgress</code>方法返回的对象。至于这儿为什么当<code>self.callbackBlocks.count == 0</code>的时候才执行<code>[self cancel]</code>,我想一个操作里面的callbackBlocks属性是一个最多只有一个字典的数组吧。值得注意的是最后调用的函数<code>cancelInternal</code>里面存在这样的一句代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf &#x3D; self;</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在主线程中post通知，这个涉及到一个知识点——<a href="">通知与多线程</a>之间的关系，通常发送消息和接收消息会在一个线程中，但是也可以改变的哦。</p>
<p>下面有两个set函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)setFinished:(BOOL)finished &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">    _finished &#x3D; finished;</span><br><span class="line">    [self didChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setExecuting:(BOOL)executing &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;isExecuting&quot;];</span><br><span class="line">    _executing &#x3D; executing;</span><br><span class="line">    [self didChangeValueForKey:@&quot;isExecuting&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实如果不写这两个函数，编译器会自动生成的，这儿重写了这两个方法，和我们平常不太一样的是多了两个方法:<code>[self willChangeValueForKey:@&quot;isFinished&quot;];</code>和<code>[self didChangeValueForKey:@&quot;isExecuting&quot;];</code>这个在执行的时候会给相应的监听者发送通知，详细的可以看<a href="">KVO</a>。</p>
<p>下面是五个<code>NSURLSessionDataDelegate</code>代理的方法的实现，它们都是可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* The task has received a response and no further messages will be</span><br><span class="line"> * received until the completion block is called. The disposition</span><br><span class="line"> * allows you to cancel a request or to turn a data task into a</span><br><span class="line"> * download task. This delegate message is optional - if you do not</span><br><span class="line"> * implement it, you can get the response as a property of the task.</span><br><span class="line"> *</span><br><span class="line"> * This method will not be called for background upload tasks (which cannot be converted to download tasks).</span><br><span class="line"> *&#x2F;</span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">                                 didReceiveResponse:(NSURLResponse *)response</span><br><span class="line">                                  completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler;</span><br></pre></td></tr></table></figure>
<p>根据注释知道：任务已经收到响应，没有其他消息接收，直到调用结束时的block。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2018/09/30/SDWebImage-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/SDWebImage-%E4%BA%8C/" itemprop="url">SDWebImage(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-30T17:05:09+08:00">
                2018-09-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###SDWebImageManager<br>.h文件里面先定义的是一个枚举，这个枚举使用<code>NS_OPTIONS</code>定义的，这和<code>NS_ENUM</code>都是官方推荐的，有兴趣了解更多的朋友们，可以戳<a href="https://developer.apple.com/library/archive/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html" target="_blank" rel="noopener">这里</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line">默认情况下，当一个URL请求失败时，将会将其加入黑名单，不会再次发起请求。这个flag禁止此特性，表明即使请求失败也不会将改URL放入黑名单中，下次还可以请求。</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageRetryFailed &#x3D; 1 &lt;&lt; 0,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">默认情况下，图片会在用户交互的时候开始下载（手滑动scrollView）。这个flag禁止此特性，会在scrollview减速的时候开始下载</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageLowPriority &#x3D; 1 &lt;&lt; 1,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">这个flag禁止磁盘缓存，只允许内存缓存</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageCacheMemoryOnly &#x3D; 1 &lt;&lt; 2,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">默认情况下，图片会在下载完全后才显示，这个flag禁止了此特性，在图片下载过程中就可以显示（像网页一样，一部分一部分地显示）</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageProgressiveDownload &#x3D; 1 &lt;&lt; 3,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">刷新缓存，默认情况下根据图片的URL生成的key重缓存查找图片，当没找到时才从磁盘找，没找到然后下载，但是当图片换了，URL没换时，就会出现问题，这个flag帮助解决这种情况</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageRefreshCached &#x3D; 1 &lt;&lt; 4,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">启动后台下载，当app进入后台时，图片继续下载，过期后就会取消</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageContinueInBackground &#x3D; 1 &lt;&lt; 5,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 通过设置处理存储在NSHTTPCookieStore中的cookie</span><br><span class="line">* NSMutableURLRequest.HTTPShouldHandleCookies &#x3D; YES;</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageHandleCookies &#x3D; 1 &lt;&lt; 6,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">允许不受信任的SSL证书。</span><br><span class="line">用于测试目的。在生产中小心使用。</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageAllowInvalidSSLCertificates &#x3D; 1 &lt;&lt; 7,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">高优先级下载，默认按照队列依次下载</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageHighPriority &#x3D; 1 &lt;&lt; 8,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">默认情况下，在图片下载之前，placeholder图片已经下载完了，这个flag禁止了这个操作，导致图片下载完后，才开始下载placholder图片</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageDelayPlaceholder &#x3D; 1 &lt;&lt; 9,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> transform Image</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageTransformAnimatedImage &#x3D; 1 &lt;&lt; 10,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">默认情况下，图像是在下载后添加到imageView。但在某些情况下，我们想</span><br><span class="line">在设置图像之前先做某些操作(例如，应用滤镜或使用交叉淡出动画添加)</span><br><span class="line">如果想在完成时手动设置图像，请使用此标志</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageAvoidAutoSetImage &#x3D; 1 &lt;&lt; 11,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">默认情况下，图像会根据原始大小进行解码。在iOS中，这个标志会缩小图像的大小与设备的有限内存兼容。</span><br><span class="line">这个flag会导致缩小的比例将被取消。</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageScaleDownLargeImages &#x3D; 1 &lt;&lt; 12,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">默认情况下，当图像缓存在内存中时，我们不会查询磁盘数据。这个掩码可以强制同时查询磁盘数据。</span><br><span class="line">此标志建议与&#39; SDWebImageQueryDiskSync &#39;一起使用，以确保图像被加载到同一个运行循环中。</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageQueryDataWhenInMemory &#x3D; 1 &lt;&lt; 13,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">默认情况下，我们同步查询内存缓存，异步查询磁盘缓存。这个掩码可以强制同步查询磁盘缓存，以确保在同一个runloop中加载映像。</span><br><span class="line">如果禁用内存缓存或在其他情况下禁用内存缓存，此标志可以避免在单元重用期间闪烁。</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageQueryDiskSync &#x3D; 1 &lt;&lt; 14,</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">默认情况下，当缓存丢失时，图像将从网络下载。这个flag可阻止网络从缓存加载。</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageFromCacheOnly &#x3D; 1 &lt;&lt; 15,</span><br><span class="line">&#x2F;**</span><br><span class="line">默认情况下，当您在图像加载完成后使用&#96;SDWebImageTransition&#96;来做一些视图转换时，这个转换只适用于从网络下载图像。这个掩码还可以强制为内存和磁盘缓存应用视图转换。</span><br><span class="line">*&#x2F;</span><br><span class="line">SDWebImageForceTransition &#x3D; 1 &lt;&lt; 16</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>后面声明了四个个block：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^SDExternalCompletionBlock)(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">typedef void(^SDInternalCompletionBlock)(UIImage * _Nullable image, NSData * _Nullable data, NSError * _Nullable error, SDImageCacheType cacheType, BOOL finished, NSURL * _Nullable imageURL);</span><br><span class="line"></span><br><span class="line">typedef NSString * _Nullable(^SDWebImageCacheKeyFilterBlock)(NSURL * _Nullable url);</span><br><span class="line"></span><br><span class="line">typedef NSData * _Nullable(^SDWebImageCacheSerializerBlock)(UIImage * _Nonnull image, NSData * _Nullable data, NSURL * _Nullable imageURL);</span><br></pre></td></tr></table></figure>
<p>参数看<code>SDInternalCompletionBlock</code>就好了，基本包含了所有的其他block的参数。<br><code>image</code>：图片，可为空<br><code>data</code>:  返回的数据，可为空<br><code>error</code>:  可能存在的问题，可为空<br><code>cacheType</code>: 图片缓存类型，不可为空<br><code>finished</code>: 是否完成，不可为空<br><code>imageURL</code>: 图片链接，可为空<br>根据意译这几个block的调用分别是：<br>外部操作完成后调用的block，<br>内部操作完成后的block（和<code>SDExternalCompletionBlock</code>不同的是，这个block只在<code>SDWebImageManager</code>里面调用，而<code>SDExternalCompletionBlock</code>是在扩展中调用），<br>将url转换成缓存key，<br>用于将解码后的图像（下载的源数据）转换为用于存储到磁盘缓存的实际数据，若返回nil,则表示从image实例生成数据</p>
<h3 id="SDWebImageManagerDelegate"><a href="#SDWebImageManagerDelegate" class="headerlink" title="SDWebImageManagerDelegate"></a>SDWebImageManagerDelegate</h3><p>该协议声明了三个可选实现的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@class SDWebImageManager;</span><br><span class="line"></span><br><span class="line">@protocol SDWebImageManagerDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Controls which image should be downloaded when the image is not found in the cache.</span><br><span class="line">*</span><br><span class="line">* @param imageManager The current &#96;SDWebImageManager&#96;</span><br><span class="line">* @param imageURL     The url of the image to be downloaded</span><br><span class="line">*</span><br><span class="line">* @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span><br><span class="line">*&#x2F;</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldDownloadImageForURL:(nullable NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Controls the complicated logic to mark as failed URLs when download error occur.</span><br><span class="line">* If the delegate implement this method, we will not use the built-in way to mark URL as failed based on error code;</span><br><span class="line">@param imageManager The current &#96;SDWebImageManager&#96;</span><br><span class="line">@param imageURL The url of the image</span><br><span class="line">@param error The download error for the url</span><br><span class="line">@return Whether to block this url or not. Return YES to mark this URL as failed.</span><br><span class="line">*&#x2F;</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldBlockFailedURL:(nonnull NSURL *)imageURL withError:(nonnull NSError *)error;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Allows to transform the image immediately after it has been downloaded and just before to cache it on disk and memory.</span><br><span class="line">* NOTE: This method is called from a global queue in order to not to block the main thread.</span><br><span class="line">*</span><br><span class="line">* @param imageManager The current &#96;SDWebImageManager&#96;</span><br><span class="line">* @param image        The image to transform</span><br><span class="line">* @param imageURL     The url of the image to transform</span><br><span class="line">*</span><br><span class="line">* @return The transformed image object.</span><br><span class="line">*&#x2F;</span><br><span class="line">- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><code>- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldDownloadImageForURL:(nullable NSURL *)imageURL;</code> : 控制在缓存中没找到图片时应该下载哪个图片<br><code>imageManager</code>: 当前的图片管理器，<code>SDWebImageManager</code>类型<br><code>imageURL</code>: 需要下载的图片的url<br>返回<code>NO</code>是阻止缓存失败时下载图片，若没有实现该函数，就默认为<code>YES</code></p>
<p><code>- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldBlockFailedURL:(nonnull NSURL *)imageURL withError:(nonnull NSError *)error;</code>: 发生下载错误时是否标记为失败的url，如果委托实现了这个方法，不会使用内置的方式标记URL为失败的基于错误代码。<br>是否阻止这个url，返回<code>YES</code>表示标记这个为失败的url，其他参数就不赘述了。</p>
<p><code>- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;</code>: 允许在图片下载成功之后（缓存在磁盘和内存之前）立马转换图片，为了避免阻塞主线程，这个方法是在全局队列里面调用的。返回被转换后的图片对象</p>
<h3 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h3><p>这个类时<code>SDWebImage</code>库里面绝对核心的一个类了，前面讲到的所有知识点（<a href="">包括SDWebImage（一）</a>）基本都是为这个类做铺垫的。我们常用的<code>API</code>基本都是依赖这个类。<br>这个类在分类<code>UIImageView+WebCache</code>后面，将异步下载（<code>SDWebImageDownloader</code>）和图像缓存（<code>SDImageCache</code>）联系在一起。相比UIView，你可以直接用这个类更好地下载和缓存<code>web image</code>(网络图像)。应用实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager *manager &#x3D; [SDWebImageManager sharedManager];</span><br><span class="line">[manager loadImageWithURL:imageURL</span><br><span class="line">options:0</span><br><span class="line">progress:nil</span><br><span class="line">completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">if (image) &#123;</span><br><span class="line">&#x2F;&#x2F; do something with image</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>该类直接继承于<code>NSObject</code>，并且定义了几个属性和方法（<a href=""><code>public</code></a>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@property (weak, nonatomic, nullable) id &lt;SDWebImageManagerDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDImageCache *imageCache;</span><br><span class="line">@property (strong, nonatomic, readonly, nullable) SDWebImageDownloader *imageDownloader;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* The cache filter is a block used each time SDWebImageManager need to convert an URL into a cache key. This can</span><br><span class="line">* be used to remove dynamic part of an image URL.</span><br><span class="line">*</span><br><span class="line">* The following example sets a filter in the application delegate that will remove any query-string from the</span><br><span class="line">* URL before to use it as a cache key:</span><br><span class="line">*</span><br><span class="line">* @code</span><br><span class="line"></span><br><span class="line">SDWebImageManager.sharedManager.cacheKeyFilter &#x3D; ^(NSURL * _Nullable url) &#123;</span><br><span class="line">url &#x3D; [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];</span><br><span class="line">return [url absoluteString];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">* @endcode</span><br><span class="line">*&#x2F;</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheKeyFilterBlock cacheKeyFilter;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* The cache serializer is a block used to convert the decoded image, the source downloaded data, to the actual data used for storing to the disk cache. If you return nil, means to generate the data from the image instance, see &#96;SDImageCache&#96;.</span><br><span class="line">* For example, if you are using WebP images and facing the slow decoding time issue when later retriving from disk cache again. You can try to encode the decoded image to JPEG&#x2F;PNG format to disk cache instead of source downloaded data.</span><br><span class="line">* @note The &#96;image&#96; arg is nonnull, but when you also provide a image transformer and the image is transformed, the &#96;data&#96; arg may be nil, take attention to this case.</span><br><span class="line">* @note This method is called from a global queue in order to not to block the main thread.</span><br><span class="line">* @code</span><br><span class="line">SDWebImageManager.sharedManager.cacheSerializer &#x3D; ^NSData * _Nullable(UIImage * _Nonnull image, NSData * _Nullable data, NSURL * _Nullable imageURL) &#123;</span><br><span class="line">SDImageFormat format &#x3D; [NSData sd_imageFormatForImageData:data];</span><br><span class="line">switch (format) &#123;</span><br><span class="line">case SDImageFormatWebP:</span><br><span class="line">return image.images ? data : nil;</span><br><span class="line">default:</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">* @endcode</span><br><span class="line">* The default value is nil. Means we just store the source downloaded data to disk cache.</span><br><span class="line">*&#x2F;</span><br><span class="line">@property (nonatomic, copy, nullable) SDWebImageCacheSerializerBlock cacheSerializer;</span><br></pre></td></tr></table></figure>
<p><code>delegate</code> : <a href="">委托</a>，<code>id &lt;SDWebImageManagerDelegate&gt;</code>类型，并且这人是一个弱引用<a href=""><code>weak</code></a>，<br><code>imageCache</code>：缓存，对外只读，对内可读可写<br><code>imageDownloader</code>：图像下载器：对外只读，对内可读可写<br><code>cacheKeyFilter</code>：<code>SDWebImageCacheKeyFilterBlock</code>类型block，将url 转换成缓存的<code>key</code>，可以用来删除图像<code>url</code>里面的动态部分,下面的示例在应用程序委托中设置一个过滤器，该过滤器将在使用它作为缓存键之前从URL中删除任何查询字符串:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager.sharedManager.cacheKeyFilter &#x3D; ^(NSURL * _Nullable url) &#123;</span><br><span class="line">url &#x3D; [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path];</span><br><span class="line">return [url absoluteString];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>cacheSerializer</code>： <code>SDWebImageCacheSerializerBlock</code>类型block，用于将解码后的图像（下载的源数据）转换为用于存储到磁盘缓存的实际数据，若返回nil,则表示从image实例生成数据。例如，如果您正在使用<code>WebP</code>图像，并且在稍后再次从磁盘缓存中检索时面临解码时间慢的问题。您可以尝试将解码后的图像编码为 <code>JPEG/PNG</code>格式到磁盘缓存，而不是源下载数据。注意<code>image</code>参数是非空的，但是当您还提供了一个图像转换器并且图像被转换时， <code>data</code> 可能是nil，请注意这种情况。为了不阻塞主线程，这个方法是从全局队列中调用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager.sharedManager.cacheSerializer &#x3D; ^NSData * _Nullable(UIImage * _Nonnull image, NSData * _Nullable data, NSURL * _Nullable imageURL) &#123;</span><br><span class="line">SDImageFormat format &#x3D; [NSData sd_imageFormatForImageData:data];</span><br><span class="line">switch (format) &#123;</span><br><span class="line">case SDImageFormatWebP:</span><br><span class="line">return image.images ? data : nil;</span><br><span class="line">default:</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>默认值为nil。意味着我们只将下载的源数据存储到磁盘缓存中。<br>对外的公共方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* Returns global SDWebImageManager instance.</span><br><span class="line">*</span><br><span class="line">* @return SDWebImageManager shared instance</span><br><span class="line">*&#x2F;</span><br><span class="line">+ (nonnull instancetype)sharedManager;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Allows to specify instance of cache and image downloader used with image manager.</span><br><span class="line">* @return new instance of &#96;SDWebImageManager&#96; with specified cache and downloader.</span><br><span class="line">*&#x2F;</span><br><span class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader NS_DESIGNATED_INITIALIZER;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Downloads the image at the given URL if not present in cache or return the cached version otherwise.</span><br><span class="line">*</span><br><span class="line">* @param url            The URL to the image</span><br><span class="line">* @param options        A mask to specify options to use for this request</span><br><span class="line">* @param progressBlock  A block called while image is downloading</span><br><span class="line">*                       @note the progress block is executed on a background queue</span><br><span class="line">* @param completedBlock A block called when operation has been completed.</span><br><span class="line">*</span><br><span class="line">*   This parameter is required.</span><br><span class="line">* </span><br><span class="line">*   This block has no return value and takes the requested UIImage as first parameter and the NSData representation as second parameter.</span><br><span class="line">*   In case of error the image parameter is nil and the third parameter may contain an NSError.</span><br><span class="line">*</span><br><span class="line">*   The forth parameter is an &#96;SDImageCacheType&#96; enum indicating if the image was retrieved from the local cache</span><br><span class="line">*   or from the memory cache or from the network.</span><br><span class="line">*</span><br><span class="line">*   The fith parameter is set to NO when the SDWebImageProgressiveDownload option is used and the image is</span><br><span class="line">*   downloading. This block is thus called repeatedly with a partial image. When image is fully downloaded, the</span><br><span class="line">*   block is called a last time with the full image and the last parameter set to YES.</span><br><span class="line">*</span><br><span class="line">*   The last parameter is the original image URL</span><br><span class="line">*</span><br><span class="line">* @return Returns an NSObject conforming to SDWebImageOperation. Should be an instance of SDWebImageDownloaderOperation</span><br><span class="line">*&#x2F;</span><br><span class="line">- (nullable id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">options:(SDWebImageOptions)options</span><br><span class="line">progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">completed:(nullable SDInternalCompletionBlock)completedBlock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Saves image to cache for given URL</span><br><span class="line">*</span><br><span class="line">* @param image The image to cache</span><br><span class="line">* @param url   The URL to the image</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">- (void)saveImageToCache:(nullable UIImage *)image forURL:(nullable NSURL *)url;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Cancel all current operations</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)cancelAll;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Check one or more operations running</span><br><span class="line">*&#x2F;</span><br><span class="line">- (BOOL)isRunning;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">*  Async check if image has already been cached</span><br><span class="line">*</span><br><span class="line">*  @param url              image url</span><br><span class="line">*  @param completionBlock  the block to be executed when the check is finished</span><br><span class="line">*  </span><br><span class="line">*  @note the completion block is always executed on the main queue</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)cachedImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">*  Async check if image has already been cached on disk only</span><br><span class="line">*</span><br><span class="line">*  @param url              image url</span><br><span class="line">*  @param completionBlock  the block to be executed when the check is finished</span><br><span class="line">*</span><br><span class="line">*  @note the completion block is always executed on the main queue</span><br><span class="line">*&#x2F;</span><br><span class="line">- (void)diskImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">*Return the cache key for a given URL</span><br><span class="line">*&#x2F;</span><br><span class="line">- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url;</span><br></pre></td></tr></table></figure>

<p>根据注释有可以知道方法的用途如下：</p>
<p><code>+ (nonnull instancetype)sharedManager;</code>：单例，返回全局对象</p>
<p><code>- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader NS_DESIGNATED_INITIALIZER;</code>：指定的初始化方法，允许图像缓存和下载器与图像管理一起使用的实例对象（通俗地说就是该图像管理器初始化时设置了缓存和图像下载器）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">options:(SDWebImageOptions)options</span><br><span class="line">progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">completed:(nullable SDInternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>返回缓存版本，如果缓存中没有则下载，两个block在前面有相关介绍（SDWebImage(一)）</p>
<ul>
<li>(void)saveImageToCache:(nullable UIImage *)image forURL:(nullable NSURL *)url;`：根据给定的url将图像存入缓存</li>
<li>(void)cancelAll;：取消当前所有的操作</li>
<li>(BOOL)isRunning;：检查是否在运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)cachedImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure>
异步检测图像是否已经缓存，检测完成之后执行block，注意：这个block是在主队列中执行。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)diskImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock;</span><br></pre></td></tr></table></figure>
异步检测图像是否已经缓存在磁盘上，block在主队列中执行<br><code>- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url;</code>：根据url返回缓存的key</li>
</ul>
<p>.m文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t failedURLsLock; &#x2F;&#x2F; a lock to keep the access to &#96;failedURLs&#96; thread-safe</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;SDWebImageCombinedOperation *&gt; *runningOperations;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t runningOperationsLock; &#x2F;&#x2F; a lock to keep the access to &#96;runningOperations&#96; thread-safe</span><br></pre></td></tr></table></figure>
<p><code>failedURLs</code>：失败的url集合<br><code>failedURLsLock</code>：一个保证能够安全访问（线程安全）<code>failedURLs</code>的一个锁，这儿是通过信号量实现的<br><code>runningOperations</code>：正在运行的操作的集合，<code>SDWebImageCombinedOperation</code>类型<br><code>runningOperationsLock</code>：一个保证能够安全访问（线程安全）<code>runningOperations</code>的锁</p>
<p>下面是方法时实现部分：<br>第一个是单例不赘述，第二个和第三个方法分别是<code>conveniented</code>和<code>designated</code> 方法，直接看第三个方法就好，这人有一个有意思的语句，在初始化中用得比较频繁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123;</span><br><span class="line">if ((self &#x3D; [super init])) &#123;</span><br><span class="line">_imageCache &#x3D; cache;</span><br><span class="line">_imageDownloader &#x3D; downloader;</span><br><span class="line">_failedURLs &#x3D; [NSMutableSet new];</span><br><span class="line">_failedURLsLock &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">_runningOperations &#x3D; [NSMutableSet new];</span><br><span class="line">_runningOperationsLock &#x3D; dispatch_semaphore_create(1);</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始是父类初始化，给<a href="">self</a>，如果<code>self</code>不为空就执行大括号里面的，否则跳过。<br>在初始化里面，可以看到都是用<a href="">下划线</a>，在初始化里面是不能用<code>self</code>点语法的，有兴趣的可以戳<a href="http://blog.devtang.com/2011/08/10/do-not-use-accessor-in-init-and-dealloc-method/" target="_blank" rel="noopener">这里</a>；我们可以看到两个集合的初始化用的是<code>new</code>而不是<code>[[NSMutableSet alloc] init]</code>，它们有什么不同吗，有兴趣的可以戳<a href="">这里</a>哦，然后是两个用信号量表示的锁了，同时允许访问的线程个数为1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)cacheKeyForURL:(nullable NSURL *)url &#123;</span><br><span class="line">if (!url) &#123;</span><br><span class="line">return @&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (self.cacheKeyFilter) &#123;</span><br><span class="line">return self.cacheKeyFilter(url);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return url.absoluteString;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若存在缓存的<code>key</code>则直接返回，否则返回完整的字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)scaledImageForKey:(nullable NSString *)key image:(nullable UIImage *)image &#123;</span><br><span class="line">return SDScaledImageForKey(key, image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据给定的图片给出一张放大或缩小的图片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">inline UIImage *SDScaledImageForKey(NSString * _Nullable key, UIImage * _Nullable image) &#123;</span><br><span class="line">if (!image) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if SD_MAC &#x2F;&#x2F;如果在mac平台</span><br><span class="line">return image;</span><br><span class="line">#elif SD_UIKIT || SD_WATCH &#x2F;&#x2F;如果有UIKIT(在tvOS或iOS，(watchOS也有UIKIT,不过非常有限))</span><br><span class="line">if ((image.images).count &gt; 0) &#123; &#x2F;&#x2F;如果是动态图</span><br><span class="line">NSMutableArray&lt;UIImage *&gt; *scaledImages &#x3D; [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;迭代，将所有的图片放在一个集合里面</span><br><span class="line">for (UIImage *tempImage in image.images) &#123;</span><br><span class="line">[scaledImages addObject:SDScaledImageForKey(key, tempImage)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将所有处理过的图片集合合成动态图</span><br><span class="line">UIImage *animatedImage &#x3D; [UIImage animatedImageWithImages:scaledImages duration:image.duration];</span><br><span class="line">if (animatedImage) &#123;</span><br><span class="line">animatedImage.sd_imageLoopCount &#x3D; image.sd_imageLoopCount;</span><br><span class="line">animatedImage.sd_imageFormat &#x3D; image.sd_imageFormat;</span><br><span class="line">&#125;</span><br><span class="line">return animatedImage;</span><br><span class="line">&#125; else &#123;&#x2F;&#x2F;是静态图</span><br><span class="line">&#x2F;&#x2F;如果是watchOS，且实现或继承了screenScale方法</span><br><span class="line">#if SD_WATCH</span><br><span class="line">if ([[WKInterfaceDevice currentDevice] respondsToSelector:@selector(screenScale)]) &#123;</span><br><span class="line">&#x2F;&#x2F;如果有UIKIT，且实现或继承了scale方法（貌似属性也能用）</span><br><span class="line">#elif SD_UIKIT</span><br><span class="line">if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line">#endif</span><br><span class="line">CGFloat scale &#x3D; 1;</span><br><span class="line">if (key.length &gt;&#x3D; 8) &#123;&#x2F;&#x2F;只有这个长度才有可能包含类似&#39;@2x.&#39;字段（l@2x.png）</span><br><span class="line">NSRange range &#x3D; [key rangeOfString:@&quot;@2x.&quot;];</span><br><span class="line">if (range.location !&#x3D; NSNotFound) &#123;</span><br><span class="line">scale &#x3D; 2.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">range &#x3D; [key rangeOfString:@&quot;@3x.&quot;];</span><br><span class="line">if (range.location !&#x3D; NSNotFound) &#123;</span><br><span class="line">scale &#x3D; 3.0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将图片按照获取的scale放大或缩小</span><br><span class="line">UIImage *scaledImage &#x3D; [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];</span><br><span class="line">scaledImage.sd_imageFormat &#x3D; image.sd_imageFormat;</span><br><span class="line">image &#x3D; scaledImage;</span><br><span class="line">&#125;</span><br><span class="line">return image;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步检测图像是否已经被缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (void)cachedImageExistsForURL:(nullable NSURL *)url</span><br><span class="line">completion:(nullable SDWebImageCheckCacheCompletionBlock)completionBlock &#123;</span><br><span class="line">NSString *key &#x3D; [self cacheKeyForURL:url];</span><br><span class="line"></span><br><span class="line">BOOL isInMemoryCache &#x3D; ([self.imageCache imageFromMemoryCacheForKey:key] !&#x3D; nil);</span><br><span class="line"></span><br><span class="line">if (isInMemoryCache) &#123;</span><br><span class="line">&#x2F;&#x2F; making sure we call the completion block on the main queue</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">if (completionBlock) &#123;</span><br><span class="line">completionBlock(YES);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[self.imageCache diskImageExistsWithKey:key completion:^(BOOL isInDiskCache) &#123;</span><br><span class="line">&#x2F;&#x2F; the completion block of checkDiskCacheForImageWithKey:completion: is always called on the main queue, no need to further dispatch</span><br><span class="line">if (completionBlock) &#123;</span><br><span class="line">completionBlock(isInDiskCache);</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在内存中缓存就在主线程中执行block，否则检测是否在磁盘缓存（block是在主队列中运行，所以这儿没必要再次处理）<br>后面一个函数也是检测是否缓存在磁盘，所以不赘述</p>
<p>返回缓存版本，如果缓存中没有则下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                     options:(SDWebImageOptions)options</span><br><span class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    &#x2F;&#x2F; Invoking this method without a completedBlock is pointless</span><br><span class="line">    &#x2F;&#x2F; 调用这个方法没有completedBlock是没有意义的，所以这儿用了断言处理</span><br><span class="line">    NSAssert(completedBlock !&#x3D; nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won&#39;t</span><br><span class="line">    &#x2F;&#x2F; throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span><br><span class="line">    &#x2F;&#x2F;用NSString对象替代NSURL传递url是非常常见的错误，处于某种奇怪的原因，类型不匹配是Xcode不会抛出任何警告，这儿我们允许url被以字符串类型传递来解决这个错误</span><br><span class="line">    if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        url &#x3D; [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Prevents app crashing on argument type error like sending NSNull instead of NSURL</span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url &#x3D; nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDWebImageCombinedOperation *operation &#x3D; [SDWebImageCombinedOperation new];</span><br><span class="line">    operation.manager &#x3D; self;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl &#x3D; NO;</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        LOCK(self.failedURLsLock);</span><br><span class="line">        isFailedUrl &#x3D; [self.failedURLs containsObject:url];</span><br><span class="line">        UNLOCK(self.failedURLsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;若url为空，或者是请求失败过的且放入黑名单中的url，这儿是&amp;（与）的妙用，下同</span><br><span class="line">    if (url.absoluteString.length &#x3D;&#x3D; 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url];</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	&#x2F;&#x2F;否则将operation操作加入runningOperation 中准备执行</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    [self.runningOperations addObject:operation];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    NSString *key &#x3D; [self cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;获取图像的缓存配置，并且将其给cacheOptions 这儿巧妙的用了|（或），在枚举中比较常见</span><br><span class="line">    SDImageCacheOptions cacheOptions &#x3D; 0;</span><br><span class="line">    if (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |&#x3D; SDImageCacheQueryDataWhenInMemory;</span><br><span class="line">    if (options &amp; SDWebImageQueryDiskSync) cacheOptions |&#x3D; SDImageCacheQueryDiskSync;</span><br><span class="line">    if (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |&#x3D; SDImageCacheScaleDownLargeImages;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;异步查询缓存，并且将包含缓存操作的操作对象给</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation &#x3D; operation;</span><br><span class="line"> </span><br><span class="line">    operation.cacheOperation &#x3D; [self.imageCache queryCacheOperationForKey:key options:cacheOptions done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">    	&#x2F;&#x2F;完成之后执行的block</span><br><span class="line">   		&#x2F;&#x2F;为了避免循环用了</span><br><span class="line">        __strong __typeof(weakOperation) strongOperation &#x3D; weakOperation;</span><br><span class="line">        &#x2F;&#x2F;若操作不存在或者被取消，则从正在运行操作集合中移除</span><br><span class="line">        if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Check whether we should download image from network</span><br><span class="line">        &#x2F;&#x2F;检测是否需要从网上下载图像：不是只从缓存获取，且不存才缓存图像或者刷新缓存，且self.delegate实现或继承了相对应的方法或者图像需要下载</span><br><span class="line">        BOOL shouldDownload &#x3D; (!(options &amp; SDWebImageFromCacheOnly))</span><br><span class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</span><br><span class="line">            &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url]);</span><br><span class="line">        if (shouldDownload) &#123;</span><br><span class="line">        &#x2F;&#x2F;若存在缓存图像且需要刷新缓存（&#96;与&#96;的优先级高于&#96;且&#96;）</span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                &#x2F;&#x2F; If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span><br><span class="line">                &#x2F;&#x2F; AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span><br><span class="line">                &#x2F;&#x2F;尝试重新下载，并刷新缓存，（但这个函数貌似这是执行completionBlock的，所以这儿没有重新下载）</span><br><span class="line">                [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; download if no image or requested to refresh anyway, and download allowed by delegate</span><br><span class="line">            &#x2F;&#x2F;若没有图像，且需要刷新，那么就下载；下面是获取图像下载的options</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions &#x3D; 0;</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |&#x3D; SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |&#x3D; SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |&#x3D; SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |&#x3D; SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |&#x3D; SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |&#x3D; SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |&#x3D; SDWebImageDownloaderHighPriority;</span><br><span class="line">            if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |&#x3D; SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;若存在缓存图像，且需要刷新缓存</span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                &#x2F;&#x2F; force progressive off if image already cached but forced refreshing</span><br><span class="line">                &#x2F;&#x2F;使得图像不支持渐进式下载，这儿用了取反</span><br><span class="line">                downloaderOptions &amp;&#x3D; ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                &#x2F;&#x2F; ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                &#x2F;&#x2F;忽略从缓存获取的图像</span><br><span class="line">                downloaderOptions |&#x3D; SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; &#96;SDWebImageCombinedOperation&#96; -&gt; &#96;SDWebImageDownloadToken&#96; -&gt; &#96;downloadOperationCancelToken&#96;, which is a &#96;SDCallbacksDictionary&#96; and retain the completed block below, so we need weak-strong again to avoid retain cycle</span><br><span class="line">            &#x2F;&#x2F; 上面的箭头是引用关系（持有关系）</span><br><span class="line">            __weak typeof(strongOperation) weakSubOperation &#x3D; strongOperation;</span><br><span class="line">            strongOperation.downloadToken &#x3D; [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong typeof(weakSubOperation) strongSubOperation &#x3D; weakSubOperation;</span><br><span class="line">                if (!strongSubOperation || strongSubOperation.isCancelled) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Do nothing if the operation was cancelled</span><br><span class="line">                    &#x2F;&#x2F; See #699 for more details</span><br><span class="line">                    &#x2F;&#x2F; if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125; else if (error) &#123;</span><br><span class="line">                    [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock error:error url:url];</span><br><span class="line">                    BOOL shouldBlockFailedURL;</span><br><span class="line">                    &#x2F;&#x2F; Check whether we should block failed url</span><br><span class="line">                    &#x2F;&#x2F;是否需要调用失败的url</span><br><span class="line">                    if ([self.delegate respondsToSelector:@selector(imageManager:shouldBlockFailedURL:withError:)]) &#123;</span><br><span class="line">                        shouldBlockFailedURL &#x3D; [self.delegate imageManager:self shouldBlockFailedURL:url withError:error];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        shouldBlockFailedURL &#x3D; (   error.code !&#x3D; NSURLErrorNotConnectedToInternet</span><br><span class="line">                                                &amp;&amp; error.code !&#x3D; NSURLErrorCancelled</span><br><span class="line">                                                &amp;&amp; error.code !&#x3D; NSURLErrorTimedOut</span><br><span class="line">                                                &amp;&amp; error.code !&#x3D; NSURLErrorInternationalRoamingOff</span><br><span class="line">                                                &amp;&amp; error.code !&#x3D; NSURLErrorDataNotAllowed</span><br><span class="line">                                                &amp;&amp; error.code !&#x3D; NSURLErrorCannotFindHost</span><br><span class="line">                                                &amp;&amp; error.code !&#x3D; NSURLErrorCannotConnectToHost</span><br><span class="line">                                                &amp;&amp; error.code !&#x3D; NSURLErrorNetworkConnectionLost);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;如果需要调用失败的url则加入到集合中</span><br><span class="line">                    if (shouldBlockFailedURL) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs addObject:url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                &#x2F;&#x2F;若不需要调用失败的URL，且在此失败，则移除</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        LOCK(self.failedURLsLock);</span><br><span class="line">                        [self.failedURLs removeObject:url];</span><br><span class="line">                        UNLOCK(self.failedURLsLock);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;是否缓存在磁盘</span><br><span class="line">                    BOOL cacheOnDisk &#x3D; !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F; We&#39;ve done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.</span><br><span class="line">                    &#x2F;&#x2F;若不是类对象的管理器且缓存key存在且图像下载成功，则缩放</span><br><span class="line">                    if (self !&#x3D; [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</span><br><span class="line">                        downloadedImage &#x3D; [self scaledImageForKey:key image:downloadedImage];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">						&#x2F;&#x2F;若刷新缓存且存在缓存图像并且图像下载失败</span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                    &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            UIImage *transformedImage &#x3D; [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line">	</span><br><span class="line">								&#x2F;&#x2F;若下载成功，且转换图像，并且实现或继承了相对应的方法</span><br><span class="line">                            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            &#x2F;&#x2F;以转换后的图与原图不一致判断是否转换成功</span><br><span class="line">                                BOOL imageWasTransformed &#x3D; ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                NSData *cacheData;</span><br><span class="line">                                &#x2F;&#x2F; pass nil if the image was transformed, so we can recalculate the data from the image</span><br><span class="line">                                &#x2F;&#x2F;若解码成功</span><br><span class="line">                                if (self.cacheSerializer) &#123;</span><br><span class="line">                                    cacheData &#x3D; self.cacheSerializer(transformedImage, (imageWasTransformed ? nil : downloadedData), url);</span><br><span class="line">                                &#125; else &#123;</span><br><span class="line">                                    cacheData &#x3D; (imageWasTransformed ? nil : downloadedData);</span><br><span class="line">                                &#125;</span><br><span class="line">                                &#x2F;&#x2F;获取缓存数据</span><br><span class="line">                                [self.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            &#x2F;&#x2F;调用completeBlock</span><br><span class="line">                            [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            if (self.cacheSerializer) &#123;</span><br><span class="line">                                dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                                    NSData *cacheData &#x3D; self.cacheSerializer(downloadedImage, downloadedData, url);</span><br><span class="line">                                    [self.imageCache storeImage:downloadedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        [self callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    [self safelyRemoveOperationFromRunning:strongSubOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125; else if (cachedImage) &#123;</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Image not in cache and download disallowed by delegate</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这人涉及到可以扩展的知识点有：<a href="">断言</a>,<a href="">NSURL的字符串</a>,<a href="">异常</a>,<a href="">逻辑运算符</a>,<a href="">优先级</a>,<a href="">NSCache</a>,<a href="">内存泄漏（包括循环）</a>,<a href="">集合</a>,以及<a href="">图像的编解码</a>。这儿先列出需要梳理的知识点，有的是平常不注意或容易出错的，有的是用得不是太多的，都是值得自己注意的。</p>
<p>下面剩下的函数，第一个是将图片存储到内存和磁盘，以url生成的key;第二个是取消所有的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)cancelAll &#123;</span><br><span class="line">    LOCK(self.runningOperationsLock);</span><br><span class="line">    NSSet&lt;SDWebImageCombinedOperation *&gt; *copiedOperations &#x3D; [self.runningOperations copy];</span><br><span class="line">    UNLOCK(self.runningOperationsLock);</span><br><span class="line">    [copiedOperations makeObjectsPerformSelector:@selector(cancel)]; &#x2F;&#x2F; This will call &#96;safelyRemoveOperationFromRunning:&#96; and remove from the array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这儿用到了<a href=""><code>copy</code></a>,看<code>self.runningOperation</code>是<code>NSMutableSet</code>类型，所以是<a href="">深复制</a>生成新的对象，并且让指针<code>copiedOperations</code>指向这个对象.<br><code>makeObjectsPerformSelector:</code>:方法是让数组或集合中的每个对象都依次执行一个方法，这儿是让集合<code>copiedOperations</code>中的对象都执行<code>cancel</code>方法，取消并清空缓存操作。<br>后面的<code>isRunning</code>函数是根据集合<code>runningOperations</code>中对象的个数是否大于零来判断的。</p>
<p>最后面的两个调用<code>completionBlock</code>的方法只看第二个就好，第一个是在第二个的基础上删减了一些参数（image、data）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)callCompletionBlockForOperation:(nullable SDWebImageCombinedOperation*)operation</span><br><span class="line">                             completion:(nullable SDInternalCompletionBlock)completionBlock</span><br><span class="line">                                  image:(nullable UIImage *)image</span><br><span class="line">                                   data:(nullable NSData *)data</span><br><span class="line">                                  error:(nullable NSError *)error</span><br><span class="line">                              cacheType:(SDImageCacheType)cacheType</span><br><span class="line">                               finished:(BOOL)finished</span><br><span class="line">                                    url:(nullable NSURL *)url &#123;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        if (operation &amp;&amp; !operation.isCancelled &amp;&amp; completionBlock) &#123;</span><br><span class="line">            completionBlock(image, data, error, cacheType, finished, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispatch_main_async_safe</code>点进去可以看到是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#ifndef dispatch_queue_async_safe</span><br><span class="line">#define dispatch_queue_async_safe(queue, block)\</span><br><span class="line">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) &#x3D;&#x3D; dispatch_queue_get_label(queue)) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(queue, block);\</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef dispatch_main_async_safe</span><br><span class="line">#define dispatch_main_async_safe(block) dispatch_queue_async_safe(dispatch_get_main_queue(), block)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>变换下，成了这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define dispatch_queue_async_safe(dispatch_get_main_queue(), block)\</span><br><span class="line">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) &#x3D;&#x3D; dispatch_queue_get_label(dispatch_get_main_queue())) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>也就是说，若满足<code>if</code>那么就直接在主线程执行<code>block</code>,否则就直接在主线程的主队列执行block.<a href="http://blog.benjamin-encz.de/post/main-queue-vs-main-thread" target="_blank" rel="noopener">GCD’s Main Queue vs. Main Thread</a>指明，若在主线程执行非主队列调度的API,那么需要检查该API是否属于主队列上调度，这样会出现问题。所以这儿先判断该队列是否为主队列（因为主队列一定是在主线程中调用的<a href="">队列与线程</a>）,若果是那么直接调用<code>block</code>（默认在主队列执行），否则就直接在主线程中执行。总之，该方法的作用就是为了在主线程中的主队列上安全地执行该<code>block</code>（completeBlock）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="Jaylan lu" />
            
              <p class="site-author-name" itemprop="name">Jaylan lu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jaylan lu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
