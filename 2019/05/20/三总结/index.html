<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="1.对mrc和arc的理解都是iOS的内存管理机制，对于内存管理就必须引入引用计数，oc中referencecount来记录一个对象的声明周期，alloc、new、copy操作都会将对象的引用加一，release减一，计数器为0时回收空间，arc是编译器特性，在mrc中对于需要release操作的地方帮我们自动加上   2.谈谈自动释放池的理解autorelease是一种支持引用计数的内存管理方式">
<meta property="og:type" content="article">
<meta property="og:title" content="三总结">
<meta property="og:url" content="https://lujaylan.github.io/2019/05/20/%E4%B8%89%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="卤蛋的博客">
<meta property="og:description" content="1.对mrc和arc的理解都是iOS的内存管理机制，对于内存管理就必须引入引用计数，oc中referencecount来记录一个对象的声明周期，alloc、new、copy操作都会将对象的引用加一，release减一，计数器为0时回收空间，arc是编译器特性，在mrc中对于需要release操作的地方帮我们自动加上   2.谈谈自动释放池的理解autorelease是一种支持引用计数的内存管理方式">
<meta property="article:published_time" content="2019-05-20T02:04:35.000Z">
<meta property="article:modified_time" content="2020-05-09T15:08:56.335Z">
<meta property="article:author" content="Jaylan lu">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://lujaylan.github.io/2019/05/20/三总结/"/>





  <title>三总结 | 卤蛋的博客</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">卤蛋的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">勤学如春起之苗，不见其增，日有所长；辍学如磨刀之石，不见其损，日有所亏</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-basics">
          <a href="/schedule/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-Basics"></i> <br />
            
            基础
          </a>
        </li>
      
        
        <li class="menu-item menu-item-cocoa">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-Cocoa"></i> <br />
            
            Cocoa
          </a>
        </li>
      
        
        <li class="menu-item menu-item-resources">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-Resources"></i> <br />
            
            源码
          </a>
        </li>
      
        
        <li class="menu-item menu-item-swift">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-Swift"></i> <br />
            
            Swift
          </a>
        </li>
      
        
        <li class="menu-item menu-item-translate">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-Translate"></i> <br />
            
            翻译
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sundry">
          <a href="/tags/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-Sundry"></i> <br />
            
            杂项
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://lujaylan.github.io/2019/05/20/%E4%B8%89%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jaylan lu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="卤蛋的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">三总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T10:04:35+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>1.对mrc和arc的理解</strong><br>都是iOS的内存管理机制，对于内存管理就必须引入引用计数，oc中referencecount来记录一个对象的声明周期，alloc、new、copy操作都会将对象的引用加一，release减一，计数器为0时回收空间，arc是编译器特性，在mrc中对于需要release操作的地方帮我们自动加上  </p>
<p><strong>2.谈谈自动释放池的理解</strong><br>autorelease是一种支持引用计数的内存管理方式，只要给对象发送一条autorelease消息，会将对象放到一个自动释放池中，当自动释放池别销毁时，会对池子里面的所有对象做一次release操作，在没有手动加autorelease pool情况下，autorelease对象是在当前runloop一次循环迭代结束时释放的，手动的是在drain时释放，而它能够释放的原因是系统在每个runloop迭代中都会加入了自动释放池push和pop<br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">链接</a>  </p>
<p><strong>3.自动释放池在mrc和arc区别</strong><br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">ARC有TLS优化</a>  </p>
<p><strong>4.多层自动释放池嵌套的对象是在哪一层释放</strong><br>当前所在的pool  </p>
<p><strong>5.对于block，理解，mrc和arc下有什么区别，使用注意事项</strong><br>NSGLobalBlock<br>若block不捕获外部变量，那么在ARC环境下就是创建一个全局block。全局block存储在全局内存中，不需要在每次调用的时候都在栈中创建，块所使用的整个内存区在编译期已经确定了，因此这种块是一种单例，不需要多次创建。<br>NSMallocBlock<br>若block捕获外部变量，那么在ARC环境下就是创建了一个堆区block，代码中最常用的block也就是堆区block，当堆区block的引用计数为0时也会像普通对象一样被销毁，再也不能使用了。<br>NSStackBlock<br>在MRC环境下，默认创建栈区block，一般使用copy函数拷贝到堆区再使用，否则block可能会被释放，在ARC环境下一般不会考虑  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* Revised new layout. *&#x2F;</span><br><span class="line">struct Block_descriptor &#123;</span><br><span class="line">    unsigned long int reserved;</span><br><span class="line">    unsigned long int size;</span><br><span class="line">    void (*copy)(void *dst, void *src);</span><br><span class="line">    void (*dispose)(void *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Block_layout &#123;</span><br><span class="line">    void *isa;</span><br><span class="line">    int flags;</span><br><span class="line">    int reserved; </span><br><span class="line">    void (*invoke)(void *, ...);</span><br><span class="line">    struct Block_descriptor *descriptor;</span><br><span class="line">    &#x2F;* Imported variables. *&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述结构体中最重要的就是invoke变量，从声明中可以看出，这是一个函数指针，指向block的执行代码，可以认为block的执行代码是一个匿名函数，在创建block的时候传递给了invoke变量。<br>struct Block_layout结构体中有一个descriptor变量，而struct Block_descriptor比较重要的就是copy函数和dispose函数，从命名就可以看出，copy函数用于捕获变量并持有引用，而dispose函数就是用于释放捕获的变量。<br>block捕获的变量都会存储在结构体struct Block_layout的后面，对于对象存储的是指针，在invoke函数执行之前全部读出。<br>以上就是block大致的实现方式，可以看出，block是一种替换函数指针的语法，相比使用函数指针更方法，写法也更便捷<br><a href="https://blog.csdn.net/u014205968/article/details/64478360" target="_blank" rel="noopener">https://blog.csdn.net/u014205968/article/details/64478360</a></p>
<p><strong>6.对于浅拷贝和深拷贝的理解</strong>  </p>
<p>容器类可变和不可变对象mutableCopy和copy都返回一个新的容器，但容器内的拷贝人员是浅拷  <a href="https://www.jianshu.com/p/b0aa9100db16" target="_blank" rel="noopener">链接</a>  </p>
<p><strong>7.对于strong weak atomic等等理解</strong><br>atomic会加锁@synchronized(self)  </p>
<p><strong>8.weak原理</strong><br>Runtime维护一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash表，key是所指对象的地址，value是weak指针的地址（这个地址的值是所指对象指针地址）数组</p>
<ol>
<li>初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。  </li>
<li>添加引用时：objc_initWeak函数会调用0bjc_storeWeak()函数，objc_storeWeak()的作用是更新指针指向，创建对应的若引用表。  </li>
<li>释放是，调用clearDeallocation函数，clearDeallocation函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，然后把这个entry从weak表中删除，最后清理对象的记录<br><a href="https://www.jianshu.com/p/13c4fb1cedea" target="_blank" rel="noopener">链接</a>  </li>
</ol>
<p><strong>9.如果属性完全不加修饰词，系统会怎么处理</strong><br>默认系统加上atomic，根据属性类型加上strong，assign  </p>
<p><strong>10.键入下block的实现</strong><br>见5  </p>
<p><strong>11.描述下IM系统如何保证消息不丢</strong><br>要想实现应用层的消息可靠投递，必须加入应用层的确认机制，即：要想让发送方Client——A确保接收方Client-B收到消息，必须让接收方Client-B给个消息的确认，这个应用层的确认流程，与消息的发送流程类似：<br>Client-B想IM-server发送一个ack请求包，即ack：R<br>IM-server在成功处理后，回复Client-B一个ack响应，即ack:A<br>则IM-Server主动向Client-A发送一个ack通知包，即ack:N<br>至此，发送”你好“的Client-A,在收到了ack:N报文后，才能确认Client-B真正接收到”你好“。<br>你会发现，一条消息的发送，分别包含(上)（下）两个半场，即msg的R/A/N三个报文，ack的R/A/N三个报文。一个应用层即时通讯消息的可靠投递，共涉及6个报文，这就是IM系统中消息投递的最核心技术  </p>
<p><strong>12.数据库如何设计表</strong><br>用户信息表  关系分组表  群组表  </p>
<p><strong>13.C++引用和指针有什么区别</strong>  </p>
<ol>
<li>指针是一个实体，需要分配内存空间。运用只是变量的别名，不需要分配内存空间  </li>
<li>指针在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（不能有引用的值不能为NULL）  </li>
<li>多级指针，但是没有多级引用，只能有一级引用。  </li>
<li>指针和引用的自增自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）  </li>
<li>sizeof引用得到的是所指向的变量（对象）的大小，而sizeof指针得到的是指针本身的大小。</li>
<li>引用访问一个变量是直接访问，而指针访问一个变量是间接访问  </li>
</ol>
<p><strong>14.http协议30x错误时什么</strong><br>301永久重定向  302临时重定向  304无修改  305使用代理请求  </p>
<p><strong>15.谈谈你懂runloop的理解：由浅入深</strong><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">链接</a>  </p>
<p><strong>16.谈谈对多线程理解：由浅入深</strong><br>耗时操作放在子线程，相对主线程来说  p_thread  NSThread  GCD  NSOPeration  </p>
<p><strong>17.谈谈category和extension区别，系统如何实现category</strong>  </p>
<ol>
<li>形式上看：extension是匿名的category  </li>
<li>extension中声明的方法需要在implementation中实现，而category不做强制要求</li>
<li>extension可以添加属性、成员变量，而category一般不可以。虽然有人说extension是一个特殊的category，也有人将extension叫做匿名分类，但是其实两者差别很大。  </li>
</ol>
<p><strong>extension</strong>  </p>
<blockquote>
<p>1.在编译器决议，是类的一部分，在编译器和头文件的@interface和实现文件里的@implement一起形成一个完整的类。<br>2.伴随着类的产生而产生，也随着类的消失而消失    </p>
</blockquote>
<ol start="4">
<li>extension一般用来隐藏类的私有消息，你必须有一个类的源代码才能添加一个类的extension，所以对于系统一些类，如NSString，就无法添加类扩展  </li>
</ol>
<p><strong>category</strong>  </p>
<blockquote>
<p>1.是运行期决议的，类扩展可以添加实例变量，分类不能添加实例变量，原因：因为在运行期，对象的内存布局已经确定，如果添加实例变量会破坏类的内部布局，这对编译性语言是灾难性的。<a href="https://www.jianshu.com/p/935e966c0c08" target="_blank" rel="noopener">链接</a><br>2.编译后会生成分类的实例方法列表和属性列表，dyld加载是会将列表添加到当前类方法列表前面  <a href="https://blog.csdn.net/a316212802/article/details/49894421" target="_blank" rel="noopener">链接</a>  </p>
</blockquote>
<p><strong>18.谈谈消息转发机制</strong><br>会经历多次转发  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)resolveInstanceMethod:(SEL)sel &#123;&#125;</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;&#125;</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>19.谈谈事件响应链，如何响应view之外的时间</strong><br>系统事件或者手势、UI刷新等时间都是被runloop捕获，苹果注册source1来监听系统事件，发生时回调_IOHIDEventSystemClientQueueCallback(),当硬件时间发生时，比如摇晃,触摸等发生又IOFramework<br>生成一个IOHIDEvent事件，由<strong>IOHIDEventSystemClientQueueCallback（）回调，当识别为一个手势时，<br>会中断当前系列回调，将UIGestureRecognizer标记为待处理，苹果注册一个Observer监测BeforeWaiting<br> _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，<br>并执行GestureRecognizer的回调。对于UI刷新事件，发生时UIVIew/CAlayer会被标记为待处理，并提交到一个<br>全局容器，苹果注册一个Observer监听BefroreWaiting和Exit，执行回调_ZN2CA11Transaction17observer_callbackEP19</strong>CFRunLoopObservermPv(),遍历所有待处理的UIView/CALayer<br>执行绘制和调整，更新UI</p>
<p>UIEvent事件传给UIApplication-&gt;UIWindow-&gt;rootVC-&gt;View-&gt;调用hittest方法递归找出最合适的View，然后<br>判断当先VIew是否能响应此事件，若不能，则传递给nextresponder,若都不能则传递直到丢弃</p>
<p>可以扩大view的响应返回，在point in view方法中扩大point的范围来实现</p>
<p><strong>20.界面性能优化</strong><br>在一个垂直同步信号过来之后，CPU核GPU未完成渲染操作而导致在缓冲区取不到对应渲染数据时就会等待下一次垂直信号来时再取数据，此帧就会被丢弃，到下一次垂直信号过来再显示新的数据时就会产生卡顿掉帧<br>CPU：对象创建，对象调整，对象销毁、布局计算、autolayout、文本计算、文本渲染、图片解码、图片绘制<br>CPU：文理渲染、视图混合、图像合成  </p>
<p>AsyncDisplayKit:ASNode代替UIVIew、CALayer,按需添加响应，更加轻量级图层预合成，将多层混合土城预合成一个Flexbox布局<br>DispatchQueuePool创建不同优先级队列来避免线程过多<br><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">链接</a></p>
<p><strong>21.聊一聊过往项目中你觉得收获最大的一个模块</strong><br>没具体模块吧，组件化、中间件  </p>
<p><strong>22.KVC和KVO实现原理</strong><br><strong>KVC:</strong>  </p>
<ol>
<li>对象中是否有set方法，有就直接调用  </li>
<li>是否有key同名的成员变量有就赋值  </li>
<li>若无继续遍历查看是否有下划线成员方法，有就赋值  </li>
<li>undefinedKey报错<br>若要做容错处理参考KVV键值验证  应用：pageController修改样式，字典转模型，全屏手势  </li>
</ol>
<p><strong>KVO</strong>  </p>
<ol>
<li>在addObserve方法中动态派生出一个子类  </li>
<li>runtime api修改self的isa指针指向子类  </li>
<li>在子类的set方法中赋值完毕后调用observer的observe方法<br>应用：加载webView加载进度  </li>
</ol>
<p><strong>23.消息转发机制和应用</strong><br>消息多层转发，runtimeUtil封装NSInvocation可以实现全局转发  </p>
<p><strong>24.响应链，如何找到最近所在的KVO</strong><br>nextResponder  </p>
<p><strong>25.微信分享大图如何实现，从进程角度</strong><br>磁层也是注册documentTypes来实现，分享到第三方时也是调用openurl，option中包含数据内容  </p>
<p><strong>26.进程（线程）间通信，举例</strong><br>schema跳转</p>
<p><strong>27.diff算法实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A &#x3D; [1行、2行、3行、4行、...]</span><br><span class="line">B &#x3D; [1行、2行、3行、4行、...]</span><br><span class="line"></span><br><span class="line">lcs &#x3D; (A, B) -&gt;</span><br><span class="line">    result &#x3D; 0</span><br><span class="line">    if A.length is 0 or B.length is 0</span><br><span class="line">        result</span><br><span class="line">    else if A[0] is B[0]</span><br><span class="line">        result &#x3D; 1 + lcs(A[1..], B[1..])</span><br><span class="line">    else</span><br><span class="line">        result &#x3D; Math.max(lcs(A, B[1..]), lcs(A[1..], B))</span><br></pre></td></tr></table></figure>

<p>拿到了lcs，然后根据计算lcs时找到的能对上的头，就可以得出两个文件最大的相同部分，用C表示，那么，A、B就被切分成了：<br>A-、C、A+<br>B-、C、B+<br>然后，我们再用同样的方法比较A-、B-，以及A+、B+，一直这样递归下去，一段段地比较，最后把所有的结果拼起来，diff就出炉啦  </p>
<p><strong>28.程序执行过程</strong> </p>
<blockquote>
<p>1.系统为程序启动做好准备开启一个进程<br>2.系统将控制权交给Dyld，Dyld会负责后续的工作<br>3.Dyld加载程序所需的动态库<br>4.Dyld对程序进行rebase以及bind操作<br>5.Objc SetUp,读取二进制中的Data字段，注册Objc类，category插入方法列表<br>6.运行初始化函数load方法，静态全局变量创建<br>7.执行程序的main函数  </p>
</blockquote>
<p><strong>29.如果想要删除自己的一段代码，如何删除（在程序执行的过程中删除）</strong><br>C++ readProcessMemory writeProcessMemory根据内存地址读写数据  </p>
<p><strong>30.属性关键字</strong><br>见7  </p>
<p><strong>31.block循环引用、如何解决、原理</strong><br>copy修饰后会到堆上面，需要管理内存，破坏循环，添加NSProxy  </p>
<p><strong>32.3中block</strong><br>见5  </p>
<p><strong>33.block和delegate比较</strong><br>block使用方法少且不易调试，delegate面向协议更推荐  </p>
<p><strong>34.通知如何实现</strong><br><a href="https://blog.csdn.net/qq_18505715/article/details/76146575" target="_blank" rel="noopener">链接</a>  </p>
<p><strong>35.autorelease pool实现原理</strong><br>见2  </p>
<p><strong>36.事物的特征</strong>  </p>
<ol>
<li>原子性（Atomicity）:<br>事物的原子性指的是，事物中包含的程序作为数据库的逻辑工作单位，它所做的对数据修改操作要么全部执行，要么完全不执行。这种特性称为原子性。</li>
<li>一致性（Consistency）:<br>事物的一致性指的是在一个事物执行之前和执行之后数据库都必须处于一致性状态。这种特性称为事物一致性。加入数据库的状态满足所有的完整性约束，就说该数据库是一致的。</li>
<li>分离性（Isolation）：<br>分离性指并发的事物是相互隔离的。即一个事物内部的操作及正在操作的数据必须封锁起来，不被其他企图进行修改的事物看到。假如并发交叉执行的事物没有任何控制，操纵相同的共享对象的多个并发事物的执行可能引起异常情况  </li>
<li>持久性（Durability）：<br>持久性意味着当前系统或介质发生故障时，确保已提交事物的更新不能丢失，即一旦一个事物提交，DBMS保证它对数据库中数据的改变应该是永久性的，即对已提交事物的更新能恢复。持久性通过数据库备份和恢复来保证。  </li>
</ol>
<p><strong>37.性能优化</strong><br>见20  </p>
<p>**38.YYModel和AFN源码<br><a href="https://www.jianshu.com/p/fe6641ef0a0c" target="_blank" rel="noopener">链接</a>  [链接](<a href="https://www.jianshu.com/p/c36159094e24" target="_blank" rel="noopener">https://www.jianshu.com/p/c36159094e24</a>  </p>
<p><strong>39.如何自己设计json转model</strong><br>runtime 获取属性再遍历赋值  </p>
<p><strong>40.主线程是相对于什么而言的</strong><br>子线程  </p>
<p><strong>41.一张图偏的内存占用大小是由什么决定的</strong><br>像素点多少，分辨率，一个像素点占位1-32bit,  计算方法：宽<em>高</em>每个像素占位/8(byte)  </p>
<p><strong>42.索引的作用</strong><br>加快检索  </p>
<p><strong>43.索引的优缺点</strong><br>有点：加快检索<br>缺点：维护成本高  </p>
<p><strong>44.在数组中找最小的k个数</strong><br>topKey算法  </p>
<p><strong>45.淘宝下拉加载更多如何优化</strong><br>不知道</p>
<p><strong>46.淘宝页面发送HTTP请求的过程</strong><br>request-&gt;dns查到服务器地址-&gt;访问服务器-&gt;服务器接收到请求内部一系列逻辑处理CDRU-&gt;返回respense-&gt;浏览器获取数据-&gt;解析渲染</p>
<p><strong>47.介绍一下MVVM</strong><br>VM类处理原C中的一些逻辑，C中只做数据绑定和一些连接控制操作</p>
<p><strong>48.知道哪些设计模式</strong><br>MVC,MVVM,MVP,Router</p>
<p>MVC的一些缺点<br>讲一讲其它架构</p>
<p><strong>49.你知道哪些编码方式</strong><br>ASCII，GB2312，gbk，unicode, UTF-8…<br><a href="https://www.cnblogs.com/xinruzhishui/p/5763894.html" target="_blank" rel="noopener">链接</a>  </p>
<p><strong>50.算法字符串翻转</strong><br><a href="https://blog.csdn.net/cghu1201/article/details/78490934" target="_blank" rel="noopener">利用数组</a>  </p>
<p><strong>51.HTTPS</strong><br>见二总结</p>
<p><strong>52.多线程的方式和它们的区别</strong><br>见一总结  </p>
<p>53.队列和线程的关系<br>线程时执行任务，队列是来限制任务的执行顺序<br>默认主线程有一个主队列</p>
<p>54.一道线程安全的题</p>
<p>55.有哪些锁<br>NSLock，NSCondication, NSRecursiveLock,@synchronized, dispatch_semaphore, OSSpinLock<br><a href="http://www.cocoachina.com/ios/20161129/18216.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20161129/18216.html</a></p>
<p>56.属性的关键字<br>见7</p>
<p>57.assign可以用于OC对象吗<br>不行，释放不能置nil</p>
<p>58.copy和strong的区别<br>copy对象会进行深拷贝，strong只是浅拷贝</p>
<p>59.weak如何实现自动赋nil<br>见8</p>
<p>60.为什么不可变对象要用copy<br>深拷贝防止被外部篡改，比如NSString对象接收NSMutableString类型时<br>若strong修饰，NSMutableString更改也会导致NSString内容梗概</p>
<p>61.assing可以使用在对象中吗<br>不行，释放不能置nil</p>
<p>62.Pod update和pod install的区别<br>podupdate会更新repo仓库，然后根据podfile中的库版本进行依赖<br>pod install之后会产生podlock文件，锁住当前依赖版本，以后每次install只会加载lock中的版本</p>
<p>63.layoutIfNeeded和setNeedsLayout的区别<br>-setNeedsLayout方法： 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，但layoutSubviews一定会被调用<br>-layoutIfNeeded方法：如果有需要刷新的标记，立即调用layoutSubviews进行布局（如果没有标记，不会调用layoutSubviews)</p>
<p>64.抓包工具抓取HTTPS的原理<br><a href="https://blog.csdn.net/leon8/article/details/52851895" target="_blank" rel="noopener">https://blog.csdn.net/leon8/article/details/52851895</a></p>
<p>65.isEquel和hash的关系<br>isEquel可能会调用hash方法</p>
<p>66.SD的源码<br>2级缓存，runloop</p>
<p>67.bitmap的结构<br>CGContextRef _Nullable CGBitmapContextCreate (<br>   void * _Nullable data,<br>   size_t width,<br>   size_t height,<br>   size_t bitsPerComponent,<br>   size_t bytesPerRow,<br>   CGColorSpaceRef _Nullable space,<br>   uint32_t bitmapInfo<br>);<br><a href="https://blog.csdn.net/hello_hwc/article/details/49614263" target="_blank" rel="noopener">https://blog.csdn.net/hello_hwc/article/details/49614263</a></p>
<p>68.可变数组的实现原理<br><a href="http://blog.joyingx.me/2015/05/03/NSMutableArray%20%E5%8E%9F%E7%90%86%E6%8F%AD%E9%9C%B2/" target="_blank" rel="noopener">http://blog.joyingx.me/2015/05/03/NSMutableArray%20%E5%8E%9F%E7%90%86%E6%8F%AD%E9%9C%B2/</a></p>
<p>69.如何hook一个对象的方法，而不影响其它对象<br>swizzle</p>
<p>70.如何避免if else<br>guard</p>
<p>71.自旋锁和互斥锁的区别</p>
<p>72.数组cop后里面的元素会复制一份新的吗<br>不会，若要新copy，则元素要实现NSCopying协议，然后遍历添加</p>
<p>73.数组的浅拷贝与深拷贝<br>见6</p>
<p>74.TCP为什么是三次握手和四次挥手<br>四次是因为要等数据传输完毕</p>
<p>75.为什么要使用HTTP？？？为什么不直接用TCP<br>http可以看作一次短暂的tcp，tcp消耗大</p>
<p>76.如何保证HTTP传输到达<br>类似于tcp为什么可靠</p>
<h1 id="77-HTTP头部有哪些内容"><a href="#77-HTTP头部有哪些内容" class="headerlink" title="77.HTTP头部有哪些内容"></a>77.HTTP头部有哪些内容</h1><p>HTTP 请求消息头部实例：<br>Host：rss.sina.com.cn<br>User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14<br>Accept：text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,<em>/</em>;q=0.5<br>Accept-Language：zh-cn,zh;q=0.5<br>Accept-Encoding：gzip,deflate<br>Accept-Charset：gb2312,utf-8;q=0.7,*;q=0.7<br>Keep-Alive：300<br>Connection：keep-alive<br>Cookie：userId=C5bYpXrimdmsiQmsBPnE1Vn8ZQmdWSm3WRlEB3vRwTnRtW &lt;– Cookie<br>If-Modified-Since：Sun, 01 Jun 2008 12:05:30 GMT<br>Cache-Control：max-age=0 </p>
<p>HTTP 响应消息头部实例：<br>Status：OK - 200 &lt;– 响应状态码，表示 web 服务器处理的结果。<br>Date：Sun, 01 Jun 2008 12:35:47 GMT<br>Server：Apache/2.0.61 (Unix)<br>Last-Modified：Sun, 01 Jun 2008 12:35:30 GMT<br>Accept-Ranges：bytes<br>Content-Length：18616<br>Cache-Control：max-age=120<br>Expires：Sun, 01 Jun 2008 12:37:47 GMT<br>Content-Type：application/xml<br>Age：2<br>X-Cache：HIT from 236-41.D07071951.sina.com.cn &lt;– 反向代理服务器使用的 HTTP 头部<br>Via：1.0 236-41.D07071951.sina.com.cn:80 (squid/2.6.STABLE13)<br>Connection：close<br>=====================================</p>
<p>78.讲一讲拥塞控制<br>慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )<br><a href="https://www.cnblogs.com/losbyday/p/5847041.html" target="_blank" rel="noopener">https://www.cnblogs.com/losbyday/p/5847041.html</a></p>
<p>79.MVVM如何实现绑定<br>C中实现绑定，VM实现C中的逻辑</p>
<p>80.block和通知的区别，分别适用什么场景<br>一对一，一对多</p>
<p>81.算法。连续问了好几个，都是数组，层层递进的，但是我忘了，只记得最后是找出数组中重复的数字<br>数组查重算法</p>
<p>82.进程和线程的区别<br>进程为一个程序，线程是进程中开辟，可以有多条。进程一般一个程序只有一个，kill进程则会收回资源<br>进程有独立的内存区，进程之间是独立的，多条线程共享数据达到高效率<br>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制<br><a href="https://www.cnblogs.com/fuchongjundream/p/3829508.html" target="_blank" rel="noopener">https://www.cnblogs.com/fuchongjundream/p/3829508.html</a></p>
<p>83.程序在运行时操作系统除了分配内存空间还有什么</p>
<p>84.进程间通信的方式</p>
<p>85.如何检测应用是否卡顿<br>人体验感，FPS工具检测</p>
<p>86.OC中对象的结构<br>struct objc_class {<br>    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</p>
<p>#if !<strong>OBJC2</strong><br>    Class _Nullable super_class                              OBJC2_UNAVAILABLE;<br>    const char * _Nonnull name                               OBJC2_UNAVAILABLE;<br>    long version                                             OBJC2_UNAVAILABLE;<br>    long info                                                OBJC2_UNAVAILABLE;<br>    long instance_size                                       OBJC2_UNAVAILABLE;<br>    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;<br>    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;<br>    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;<br>    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;<br>#endif</p>
<p>} OBJC2_UNAVAILABLE;</p>
<p>87.多态<br>基类指针指向子对象，调用基类方法，动态找到子类实现</p>
<p>88.Ping是什么协议<br>网络层ICMP协议，属于TCP/IP协议簇</p>
<p>89.知道MTU吗</p>
<p>90.TCP头部多长，IP呢<br>IP：通常20字节，有选项时更长，总共不超过60字节</p>
<p>TCP：一般为20字节，选项最多40字节，限制60字节</p>
<p>MAC帧：</p>
<p>91.线程同步的方式<br>加锁，或者把同时访问的改为只读</p>
<p>92.iOS中有哪些锁<br>互斥锁    如果多个线程同时竞争一个互斥锁,那么只有一个将被允许访问，其他将被block。<br>递归锁    递归锁是互斥锁上的一个变体。递归锁允许单个线程在释放锁之前多次获取锁。其他线程仍然被阻塞，直到锁的所有者释放锁的次数相同。递归的锁在递归迭代中主要使用，但也可以在需要单独获取锁的多个方法中使用。<br>读写锁    读写锁也被称为共享独占锁。这种类型的锁通常用于更大规模的操作，如果保护的数据结构经常被频繁地读取和修改，则可以显著提高性能。在正常运行期间，多个阅读器可以同时访问数据结构。当一个线程想要写入结构时，它会阻塞，直到所有的读取器释放锁为止，这时它会获得锁并更新结构。当一个写线程在等待锁的时候，新的读取器线程阻塞，直到写线程完成。该系统只支持使用POSIX线程的读写锁。有关如何使用这些锁的更多信息，请参见pthread手册页。<br>分布锁    分布式锁在流程级别上提供互斥的访问。与真正的互斥锁不同，分布式锁不会阻塞进程或阻止进程运行。它只是报告当锁很忙时，让流程决定如何进行。<br>自旋锁    自旋锁定期轮询其锁状态，直到该条件变为真。自旋锁在多处理器系统中最常用，因为锁的等待时间很小。在这种情况下，进行轮询通常比阻塞线程更有效，这涉及到上下文切换和线程数据结构的更新。<br>双重检查锁定    双重检查锁定试图采取一个锁的开销减少测试前锁定标准锁<br><a href="http://www.linyibin.cn/2015/04/18/ios-Thread-Sync/" target="_blank" rel="noopener">http://www.linyibin.cn/2015/04/18/ios-Thread-Sync/</a></p>
<p>93.MVC和MVVM的区别<br>VM处理逻辑，减轻C负担</p>
<p>94.了解哪些设计模式<br>factory，单例，代理，MVP，路由</p>
<p>95.存一个通讯录，包括增删改查，用什么数据结构<br>链表</p>
<p>96看过哪些源码，讲讲思路<br>SD，MJ，AsynDisplayKit，HandyJSON</p>
<p>97.两个链表找第一个相同结点<br><a href="https://blog.csdn.net/Audience_/article/details/77648916" target="_blank" rel="noopener">https://blog.csdn.net/Audience_/article/details/77648916</a></p>
<p>98.字符串旋转</p>
<p>99.找链表的倒数第k个结点<br>linkList reverse(linkList head){<br>  linkList p,q,pr;<br>  p = head-&gt;next;<br>  q = NULL;<br>  head-&gt;next = NULL;<br>  while(p){<br>    pr = p-&gt;next;<br>    p-&gt;next = q;<br>    q = p;<br>    p = pr;<br>  }<br>  head-&gt;next = q;<br>  return head;<br>}<br>先反转再查第k个<br><a href="https://blog.csdn.net/blioo/article/details/62050967" target="_blank" rel="noopener">https://blog.csdn.net/blioo/article/details/62050967</a></p>
<p>100.把一个链表比某个值大的放在左边，比它小的放在右边</p>
<p>101.二叉树的中序遍历，非递归</p>
<p>102.进程和线程的区别<br>见82</p>
<p>103.一个进程有哪些区<br>堆、栈、静态区、常量区、代码区</p>
<p>104.拥塞控制<br>见78</p>
<p>105.进程间通信的方式<br><a href="https://blog.csdn.net/wh_sjc/article/details/70283843" target="_blank" rel="noopener">https://blog.csdn.net/wh_sjc/article/details/70283843</a></p>
<p>106.七层模型</p>
<p>107.TCP和UDP的区别<br>可靠与不可靠</p>
<p>108.传输层和网络层分别是做什么的<br>传输层主要用来对数据的检验、去重、排序，验证作用<br>网络层路由协议，</p>
<p>109.UDP可以实现一对多？？</p>
<p>110.算法 求数组的最长子数组</p>
<p>111.Http2.0如1.x的区别<br><a href="https://www.cnblogs.com/frankyou/p/6145485.html" target="_blank" rel="noopener">https://www.cnblogs.com/frankyou/p/6145485.html</a></p>
<p>112.发送一个HTTP请求的过程<br><a href="https://www.cnblogs.com/engeng/articles/5959335.html" target="_blank" rel="noopener">https://www.cnblogs.com/engeng/articles/5959335.html</a></p>
<p>113.TCP是如何保证可靠的<br>见二总结</p>
<p>114.内核态和用户态的区别<br><a href="https://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html" target="_blank" rel="noopener">https://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html</a></p>
<p>115.在一个10G的数据里面找出最大的100个数<br>见一总结</p>
<p>116.讲一下我最满意的一个项目<br>求苗</p>
<p>117.然后讲了一下网络造成卡顿的原因<br>网络阻塞，带宽不够，硬件问题</p>
<p>118.属性的关键字方面的<br>见7</p>
<p>119.内存管理方面的<br>120.多线程<br>121.各种队列<br>122.线程锁<br>123.MVVM</p>
<p>124.两个字符串是否为旋转字符串<br>两个b拼接在一起赋值给c，查看c中是否包含字符串a，若包含，则返回true；否则返回false</p>
<p>125.Clang和llvm</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/19/%E6%80%BB%E7%BB%93%E4%BA%8C/" rel="next" title="总结二">
                <i class="fa fa-chevron-left"></i> 总结二
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/20/%E5%9B%9B%E6%80%BB%E7%BB%93/" rel="prev" title="四总结">
                四总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/cat.jpeg"
                alt="Jaylan lu" />
            
              <p class="site-author-name" itemprop="name">Jaylan lu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#77-HTTP头部有哪些内容"><span class="nav-number">1.</span> <span class="nav-text">77.HTTP头部有哪些内容</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jaylan lu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
